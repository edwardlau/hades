<?xml version="1.0" encoding="UTF-8"?>
<!-- 
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
	"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
	-->
<book>
  <bookinfo>
    <title>Hades</title>

    <subtitle>Domain class and DAO development framework</subtitle>

    <authorgroup>
      <author>
        <firstname>Oliver</firstname>

        <surname>Gierke</surname>

        <affiliation>
          <jobtitle>Software architect</jobtitle>

          <orgname>Synyx GmbH &amp; Co. KG</orgname>
        </affiliation>

        <email>gierke@synyx.de</email>

        <address>Karlstra√üe 68, 76137 Karsruhe, Germany</address>
      </author>
    </authorgroup>

    <releaseinfo>V0.2</releaseinfo>

    <pubdate>25.09.2008</pubdate>

    <copyright>
      <year>2008</year>

      <holder>Synyx GmbH &amp; Co. KG</holder>
    </copyright>

    <revhistory>
      <revision>
        <date>29.04.2008</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Initial draft</revremark>
      </revision>

      <revision>
        <date>13.05.2008</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>RC1</revremark>
      </revision>

      <revision>
        <date>13.05.2008</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>RC2 - Added auto configuration, annotation configuration
        for namespaces and finder methods for single instances</revremark>
      </revision>
    </revhistory>
  </bookinfo>

  <preface>
    <title>Preface</title>

    <section>
      <title>Assumtions</title>

      <para>As Hades makes heavy use of Spring and JPA we assume you have
      certain knowledge of how to work with theses frameworks and
      specifications. Hades is implemented using some container hooks of
      Spring, AOP features. Nevetheless you do not have to have deep insight
      in conainer internals to use Hades although it would let you understnad
      things more deeply.</para>
    </section>

    <section>
      <title>Technologies</title>

      <simplesect>
        <title>JPA</title>

        <para>The Java Persistence API was invented in conjunction with EJB3
        and serves as standard for persisting objects in JavaSE and JavaEE
        environments. It abstracts differences of various available OR Mappers
        like Hibernate and Toplink and guarantees interoperability as far as
        possible. Although the version 1.0 has its shortcomings, JPA can be
        considered a future technology.</para>
      </simplesect>

      <simplesect>
        <title>Spring</title>

        <para>Spring is the defacto standard application framework for Java
        applications. Its consistent programming model, easy configuration and
        wide support for all kinds of third party libraries makes it the first
        class citizen of application frameworks.</para>
      </simplesect>

      <simplesect>
        <title>Spring &amp; JPA</title>

        <para>Spring offers a lot of support for various technologies in data
        access area. It's main benefit regarding JPA is the ease and power of
        configuration along with proper exception translation into Spring's
        DataAccessException hierarchy</para>
      </simplesect>
    </section>
  </preface>

  <chapter>
    <title>Core concepts</title>

    <section>
      <title>Introduction</title>

      <para>Implementing a data access layer of an application has been
      cumbersome for quite a while. To much bilerplate code had to be written.
      Domain classes were anemic and havent been designed in a real object
      oriented or domain driven manner.</para>

      <para>The last few years have brought a lot of evolution regarding those
      topics. JPA brought annotation driven persistence into Java, Spring
      established as lightweight Java development framework offering a lot of
      support especially in the area of data access.</para>

      <para>Using both of these technologies makes developers life a lot
      easier regarding rich domain model's persistence. Nevertheless the
      amount of boilerplate code especially for DAOs is still quite high.
      Besides that there is no higher level concept supporting you designing
      persistent domain classes. Hades is aiming to bridge that gap, providing
      sophisticated support for domain modeling and easing persistence.</para>

      <para>The following chapters will introduce the core concepts and
      interfaces of Hades roughly surrounding various steps of sophistication.
      All these step will bring significant benefit to your application but
      will introduce certain restrictions. So it's up to you to choose.</para>
    </section>

    <section>
      <title>Entities and DAOs</title>

      <para>The two central interfaces in Hades are Entity and GenericDao.
      Entity defines the core contract for persistent domain classes that a
      GenericDao can handle. GenricDao itself provides sophisticated support
      for CRUD operations. Beyond that the base implementation of that
      interface provides even more sophisticated features. Read more on that
      below.</para>

      <example>
        <title>Persistable interface</title>

        <programlisting language="java">public interface Persistable&lt;PK extends Serializable&gt; {

  public PK getId();

  public boolean isNew();

}</programlisting>
      </example>

      <para>Persistables have to be identifyable to be retrieved from the
      database. Thus your entities will have to provide an id or primary key.
      The id can be of any serializable type, beginning with rather simple
      types like Integer or Long up to complex multi column dedicated key
      classes. The parameterization of the interface will ensure typesafety on
      the id.</para>

      <para>The <code>isNew()</code> method is used by
      <interfacename>GenericDao</interfacename> implementations to distinguish
      a lot of operations and thus abstracting e.g. an <code>INSERT</code>
      from an <code>UPDATE</code>.</para>

      <para>Implementing <interfacename>Persistable</interfacename> will allow
      your domain class to be persisted by the default Hades
      <interfacename>GenericDao</interfacename> implementation and leaves any
      opportunity to implement certain class hierarchies to you. This freedom
      results in a few standard JPA configuration tasks you have to do
      manually. Hades provides more sophisticated base classes your entities
      can extend. This will couple your domain class code more tightly to
      Hades but frees you from implementing boilerplate JPA code.</para>

      <para>Let's take a look at the <interfacename>GenericDao</interfacename>
      interface that provides CRUD operations for entities.</para>

      <example id="example.generic-dao">
        <title>GenericDao Interface</title>

        <programlistingco>
          <areaspec>
            <area coords="4" id="generic-dao.save" />

            <area coords="6" id="generic-dao.save-and-flush" />

            <area coords="8" id="generic-dao.read-by-primary-key" />

            <area coords="10" id="generic-dao.read-all" />

            <area coords="12" id="generic-dao.read-all-pageable" />

            <area coords="14" id="generic-dao.count" />

            <area coords="16" id="generic-dao.delete" />

            <area coords="18" id="generic-dao.flush" />
          </areaspec>

          <programlisting language="java">public interface GenericDao&lt;T extends Persistable&lt;PK&gt;, PK extends Serializable&gt;
        extends FinderExecuter&lt;T&gt; {

    T save(T persistable);

    T saveAndFlush(T persistable);

    T readByPrimaryKey(PK primaryKey);

    List&lt;T&gt; readAll();

    Page&lt;T&gt; readAll(Pageable pageable);

    Long count();

    void delete(T persistable);

    void flush();
}</programlisting>

          <calloutlist>
            <callout arearefs="generic-dao.save">
              <para>Saves the given entity.</para>
            </callout>

            <callout arearefs="generic-dao.save-and-flush">
              <para>Saves the given entity and immediately flushes changes to
              the database.</para>
            </callout>

            <callout arch="" arearefs="generic-dao.read-by-primary-key">
              <para>Returns the entity identified by the given id.</para>
            </callout>

            <callout arearefs="generic-dao.read-all">
              <para>Returns all entities.</para>
            </callout>

            <callout arch="" arearefs="generic-dao.read-all-pageable">
              <para>Returns a page of entities.</para>
            </callout>

            <callout arearefs="generic-dao.count">
              <para>Returns the number of entities.</para>
            </callout>

            <callout arearefs="generic-dao.delete">
              <para>Deletes the given entity.</para>
            </callout>

            <callout arearefs="generic-dao.flush">
              <para>Flushes pending changes to the database.</para>
            </callout>
          </calloutlist>
        </programlistingco>
      </example>

      <para>Hades provides a <classname>GenericDaoFactoryBean</classname> that
      allows setting up instances for this interface in declarative manner. So
      all you need to do is declaring an interface extending and thus typing
      the generic interface accordingly.</para>

      <para>For more sophisticated DAO operations Hades provides
      ExtendedGenericDao. It contains functionality that can not be
      implemented with standard JPA features in the current version. So
      implementations will have to rely on persistence providers proprietary
      API. Extending this interface with your concrete DAO interface will
      require to configure a custom DAO implementation to
      GenericDaoFactoryBean. Hades currently offers an implementation based on
      Hibernate.</para>

      <example>
        <title>ExtendedGenericDao interface</title>

        <programlistingco>
          <areaspec>
            <area coords="4" id="extended-generic-dao.read-by-example" />

            <area coords="6"
                  id="extended-generic-dao.read-by-example-pageable" />
          </areaspec>

          <programlisting language="java">public interface ExtendedGenericDao&lt;T extends Persistable&lt;PK&gt;, PK extends Serializable&gt;
        extends GenericDao&lt;T, PK&gt; {

    List&lt;T&gt; readByExample(T... examples);

    List&lt;T&gt; readByExample(Pageable pageable, T... examples);
}</programlisting>

          <calloutlist>
            <callout arearefs="extended-generic-dao.read-by-example">
              <para>Returns all entities matching the given examples. if you
              provide more that one example, their restrictions will be OR
              concatenated.</para>
            </callout>

            <callout arearefs="extended-generic-dao.read-by-example-pageable">
              <para>Returns a single page of the restriction result defined by
              the given example.</para>
            </callout>
          </calloutlist>
        </programlistingco>
      </example>
    </section>

    <section>
      <title>Auditablity</title>

      <para>Most applications will require some auditability for entities
      allowing to track creation date and user and modification date and user.
      Hades provides facilities to add this audition information to entity
      transparently by AOP means. To take part in this functionality your
      domain classes have to implement a more advanced interface:</para>

      <example>
        <title>Auditable interface</title>

        <programlisting language="java">public interface Auditable&lt;U extends Persistable&lt;PK&gt;, PK extends Serializable&gt;
        extends Persistable&lt;PK&gt; {

    U getCreatedBy();

    void setCreatedBy(U createdBy);

    Date getCreatedDate();

    void setCreated(Date creationDate);

    U getLastModifiedBy();

    void setLastModifiedBy(U lastModifiedBy);

    Date getLastModifiedDate();

    void setLastModified(Date lastModifiedDate);
}</programlisting>
      </example>

      <para>As you can see the modifying entity itself only has to be an
      entity. Mostly this will be some sort of User entity, so we chose U as
      parameter type.</para>

      <note>
        <para>To minimize boilerplate code Hades offers
        <classname>AbstractPersistable</classname> and
        <classname>AbstractAuditablePersistable</classname> base classes that
        implement and preconfigure entities. Thus you can decide to only
        implement the interface or enjoy more sophisticated support by
        extending the base class. Hades will never force you to use
        inheritance!</para>
      </note>

      <simplesect>
        <title>AuditionAdvice</title>

        <para>The <classname>AuditionAdvice</classname> is used to
        transparently set audition information during the work with the DAO.
        The advice gets access to the user changing or creating the entity
        through the <interfacename>AuditorAware</interfacename>
        interface.</para>

        <example>
          <title>CurrentUserAware interface</title>

          <programlisting language="java">public interface AuditorAware&lt;T extends Persistable&lt;PK&gt;, 
  PK extends Serializable&gt; {

    T getCurrentAuditor();
}</programlisting>
        </example>

        <para>Usually you will have some kind of authentication component in
        your application that tracks the user currently working with the
        system. This component should be
        <interfacename>AuditorAware</interfacename> and thus allow seemless
        tracking of the auditioner.</para>

        <para>To activate transparent creation of auditioning information the
        configuration has to look something like this:</para>

        <example>
          <title>Configuration of AuditionAdvice</title>

          <para></para>

          <programlistingco>
            <areaspec>
              <area coords="9" id="audition-advice.aop-activation" />

              <area coords="11" id="audition-advice.audition-advice" />

              <area coords="15" id="audition-advice.current-user-aware" />
            </areaspec>

            <programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:aop="http://www.springframework.org/schema/aop"
  xsi:schemaLocation="http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
    http://www.springframework.org/schema/aop 
    http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

  &lt;aop:aspectj-autoproxy /&gt;

  &lt;bean class="org.synyx.hades.domain.support.AuditionAdvice"&gt;
    &lt;property name="auditorAware" ref="auditorAware" /&gt;
  &lt;/bean&gt;

  &lt;bean id="auditorAware" class="foo.bar.AuthenticationService" /&gt;

&lt;/beans&gt;</programlisting>

            <calloutlist>
              <callout arearefs="audition-advice.aop-activation">
                <para>Activate auto proxy creation for spring beans.</para>
              </callout>

              <callout arearefs="audition-advice.audition-advice">
                <para>Declare the advice as spring bean and add a reference to
                the <interfacename>AuditiorAware</interfacename>.</para>
              </callout>

              <callout arearefs="audition-advice.current-user-aware">
                <para>Declare a spring bean that implements
                <interfacename>AuditorAware</interfacename>.</para>
              </callout>
            </calloutlist>
          </programlistingco>
        </example>
      </simplesect>
    </section>
  </chapter>

  <chapter>
    <title>Sample application</title>

    <section>
      <title>Introduction</title>

      <para>In order to introduce you to working with Hades we will develop a
      small sample application managing users. As Hades is focussing on
      development of domain classes and persistence it will not be a full
      fledged application but rather concentrate on that particular part of an
      application built around the demo app.</para>

      <para>We will start by assuming that only want to have basic Hades
      support stepping forward using more sophisticated features of it.</para>

      <section>
        <title>JPA</title>

        <para>Hades is considered a DAO framework to work with JPA. Although
        the DAO abstraction could be to simple JDBC access, too, we focus on
        JPA in this release. This concludes in support for all major JPA
        persistence provders like Hibernate, OpenJPA and Toplink.</para>

        <note>
          <para>Although Toplink Essentials is the JPA reference
          implementation it does not implement all features specified and
          furthermore shows some bugs regarding cascading persistence. Thus we
          advice to choose some other library instead, e.g. Hibernate.</para>
        </note>
      </section>

      <section>
        <title>Configuration</title>

        <para>To get started with Hades you need to setup your application in
        the standard Spring manner. The following examples leverage XML
        configuration style of the container but you could easily use other
        approaches as well. We will separate configuration into two files.
        <filename>infrastructure.xml</filename> contains a the basic
        infrastructure setup descibed in the next chapter. This one will be
        used over the various sophistication levels of Hades. Beyond that we
        will create certain further config files that contain configuration
        for various sophistication levels.</para>
      </section>
    </section>

    <section id="infrastructure">
      <title>Infrastructure</title>

      <simplesect>
        <title>DataSource</title>

        <para>As you might already know, Spring's data base access support is
        mainly centered around working with a
        <interfacename>DataSource</interfacename> implementation. Although you
        should rely on more sophisticated
        <interfacename>DataSource</interfacename> implementations like Commons
        DBCP, Spring comes with <classname>DriverManagerDataSource</classname>
        out of the box that should be satisfying for testing purposes.</para>

        <note>
          <para>Environment specific configuration that highly varies between
          deployments should not be hardcoded into a Spring configuration
          file. Preferably, use a
          <classname>PropertyPlaceholderConfigurer</classname><footnote>
              <para>For more information see <ulink
              url="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-factory-placeholderconfigurer">Spring's
              reference documentation</ulink> on that topic</para>
            </footnote> to externalize those kinds of settings into an
          external properties file that can easily customized by application
          administrators.</para>
        </note>

        <para>So we setup an instance of it in typical Spring Dependency
        Injection manner.</para>

        <example>
          <title>DataSource configuration</title>

          <programlistingco>
            <areaspec>
              <area coords="3" id="data-source.driver-class-name" />

              <area coords="4" id="data-source.url" />

              <area coords="5" id="data-source.username" />

              <area coords="6" id="data-source.password" />
            </areaspec>

            <programlisting language="xml">&lt;bean id="dataSource" 
  class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
  &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt;
  &lt;property name="url" value="jdbc:mysql://localhost:3306/hades" /&gt;
  &lt;property name="username" value="username" /&gt;
  &lt;property name="password" value="password" /&gt;
&lt;/bean&gt;</programlisting>

            <calloutlist>
              <callout arearefs="data-source.driver-class-name">
                <para>Configure your database vendor's specific driver
                class</para>
              </callout>

              <callout arearefs="data-source.url">
                <para>Point the data source to your database's location</para>
              </callout>

              <callout arearefs="data-source.username data-source.password">
                <para>Authentication credentials</para>
              </callout>
            </calloutlist>
          </programlistingco>
        </example>
      </simplesect>

      <simplesect>
        <title>EntityManager(Factory)</title>

        <example>
          <title>EntityManager configuration</title>

          <programlistingco>
            <areaspec>
              <area coords="3" id="entity-manager-factory.data-source" />

              <area coords="4" id="entity-manager-factory.jpa-vendor-adapter" />
            </areaspec>

            <programlisting language="xml">&lt;bean id="entityManagerFactory"
  class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="dataSource" ref="dataSource" /&gt;
  &lt;property name="jpaVendorAdapter"&gt;
    &lt;bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"&gt;
      &lt;property name="showSql" value="true" /&gt;
      &lt;property name="generateDdl" value="true" /&gt;
      &lt;property name="database" value="MYSQL" /&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

            <calloutlist>
              <callout arearefs="entity-manager-factory.data-source">
                <para>Reference the DataSource declared before</para>
              </callout>

              <callout arearefs="entity-manager-factory.jpa-vendor-adapter">
                <para>Apply a vendor specific adapter to add further
                configuration. In this case we use Hibernate and tell it to
                use MySQL dialect for accessing the database, generate the
                required database tables as needed and log SQL queries fired
                to the database</para>
              </callout>
            </calloutlist>
          </programlistingco>
        </example>
      </simplesect>

      <simplesect>
        <title>Transaction management</title>

        <para>Spring leverages consistent transaction abstraction through its
        <interfacename>PlatformTransactionManager</interfacename> interface
        and provides a <classname>JpaTransactionManager</classname>
        implementation out of the box.</para>

        <example>
          <title>Transaction manager configuration</title>

          <programlisting language="xml">&lt;bean id="transactionManager"
  class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
  &lt;property name="entityManagerFactory" ref="entityManagerFactory" /&gt;
&lt;/bean&gt;</programlisting>
        </example>
      </simplesect>
    </section>

    <section>
      <title>Basic entities and DAOs</title>

      <para>Working with Hades will offer support working with domain classes
      and DAOs for the domain classes. The Data Access Objects pattern is a
      well known and widely adopted pattern to implement persistent objects.
      Nevertheless implementing DAOs for domain classes ist often cumbersome
      and results in boilerplate code.</para>

      <para>Generic approaches to DAO implementation can head two different
      roads. One approach is to implement exactly one DAO instance that can
      handle all domain classes. This mostly concludes in passing the domain
      classes type into every method call and thus makes the interface rather
      technical and clutters it with unnatural parameters.</para>

      <section>
        <title>Users and roles</title>

        <para>As we want to create a small user management application, the
        primary entities we will deal with are <classname>User</classname> and
        <classname>Role</classname>. Take a look at the code snippets:</para>

        <example>
          <title>User entity</title>

          <programlisting language="java">@Entity
public class User implements Persistable&lt;Long&gt; {

  public static final long serialVersionUID = 123L

  @Id
  @GeneratedValue(strategy = GenerationType.AUTO)
  private Long id;
  private String username;
  private String password;
  private String emailAddress;

  @ManyToMany
  private Set&lt;Role&gt; roles;

  public Long getId() {
    return this.id;
  }

  // Further getters and setters omitted

  public boolean isNew() {
    return null == this.id;
  }
}</programlisting>
        </example>

        <para>Note that we decide to have an id type of
        <classname>Long</classname>. We have to add annotations for the id
        ourselves and implement <methodname>isNew()</methodname> manually,
        too. We create a many-to-many relationship to the <code>Role</code>
        class and store some string values like username, password and email
        address.</para>

        <example>
          <title>Role entity</title>

          <programlisting language="java">@Entity
public class Role implements Persistable&lt;Integer&gt; {

  private static final long serialVersionUID = -123L;

  @Id
  @GeneratedValue(strategy = GenerationType.AUTO)
  private Integer id;
  private String name;

  public Integer getId() {
    return this.id;
  }

  // Further getters and setters omitted

  public boolean isNew() {
    return null == this.id;
  }
}</programlisting>
        </example>

        <para>The <classname>Role</classname> class looks quite similar. Note
        that we decide for an alternate id type. So mixing id type is no
        problem at all.</para>
      </section>

      <section>
        <title>DAOs</title>

        <para>As we have modeled the entities we need to add an interface for
        a DAO handling persistence operations for them:</para>

        <example>
          <title>UserDao and RoleDao interface</title>

          <programlisting language="java">public interface UserDao extends GenericDao&lt;User, Long&gt; {
}</programlisting>

          <programlisting language="java">public interface RoleDao extends GenericDao&lt;Role, Integer&gt; {
}</programlisting>
        </example>

        <para>As you can see the interfaces serve typing purposes only for
        now. We will add further functionality to them later.
        <interfacename>GenericDao</interfacename> provides most of the
        required persistence operations. Hades provides various
        implementations of this interface so that you don't need to code one
        on your own.</para>
      </section>

      <section>
        <title>Configuration</title>

        <para><classname>GenericJpaDao</classname> is the base implementation
        of <interfacename>GenericDao</interfacename> that serves basic
        purposes very well. It uses Spring's exception translation and entity
        manager injection facilities so that its creation logic is
        encapsulated into <classname>GenericJpaDaoFactoryBean</classname>. So
        the basic configuration for a DAO instance looks as follows:</para>

        <example>
          <title>Simple DAO configuration</title>

          <programlistingco>
            <areaspec>
              <area coords="1" id="simple-dao-config.infrastructure-import" />

              <area coords="5" id="simple-dao-config.domain-class" />

              <area coords="6" id="simple-dao-config.dao-interface" />
            </areaspec>

            <programlisting language="xml">&lt;import resource="infrastructure.xml" /&gt;

&lt;bean id="userDao" 
    class="org.synyx.hades.dao.orm.support.GenericDaoFactoryBean"&gt;
  &lt;property name="domainClass" value="org.synyx.hades.domain.User" /&gt;
  &lt;property name="daoInterface" value="org.synyx.hades.dao.UserDao" /&gt;
&lt;/bean&gt;

&lt;bean id="roleDao"
    class="org.synyx.hades.dao.orm.support.GenericDaoFactoryBean"&gt;
  &lt;property name="domainClass" value="org.synyx.hades.domain.Role" /&gt;
  &lt;property name="daoInterface" value="org.synyx.hades.dao.RoleDao" /&gt;
&lt;/bean&gt;</programlisting>

            <calloutlist>
              <callout arearefs="simple-dao-config.infrastructure-import">
                <para>Import infrastructure configuration. Supposed we have
                combined the configuration examples shown in <link
                linkend="infrastructure">Infrastructure section</link> into a
                file named <filename>infrastructure.xml</filename>.</para>
              </callout>

              <callout arearefs="simple-dao-config.domain-class">
                <para>Declare the domain class that you want to persist. This
                class has to implement
                <interfacename>Persistable</interfacename>.</para>
              </callout>

              <callout arearefs="simple-dao-config.dao-interface">
                <para>Declare the DAO interface you want to expose. This
                interface has to extend
                <interfacename>GenericDao</interfacename>.</para>
              </callout>
            </calloutlist>
          </programlistingco>
        </example>
      </section>

      <section>
        <title>Client code</title>

        <para>The previously declared <interfacename>UserDao</interfacename>
        can be accessed via its bean id from the ApplicationContext, although
        you definately are better off letting the container inject it into you
        client:</para>

        <example>
          <title>Manual lookup of UserDao</title>

          <programlisting language="java">ApplicationContext ctx = new ClasspathXmlApplicationContext(
  "applicationContext.xml");
UserDao userDao = (UserDao) ctx.getBean("userDao");

User user = userDao.readByPrimaryKey(1L);</programlisting>
        </example>
      </section>
    </section>

    <section>
      <title>Easing configuration - Spring namespaces</title>

      <para>Configuring DAOs the standard way can become cumbersome if your
      application requires a lot of DAOs. With help of Spring 2.5 namespaces
      there is a more sophisticated way to configure them.</para>

      <example>
        <title>DAO configuration with Spring namespaces</title>

        <programlistingco>
          <areaspec>
            <area coords="4" id="config.dao-ns-import" />

            <area coords="7" id="config.dao-ns-location" />

            <area coords="10" id="config.import-infrastructure" />

            <area coords="12" id="config.dao-config" />

            <area coords="16" id="config.dao-instance" />
          </areaspec>

          <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:dao="http://www.synyx.de/schema/dao"
  xsi:schemaLocation="http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
    http://www.synyx.de/schema/dao 
    http://www.synyx.de/schema/dao/dao-config.xsd"&gt;

  &lt;import resource="infrastructure.xml" /&gt;

  &lt;dao:dao-config
    entity-package-name="org.synyx.hades.domain"
    dao-package-name="org.synyx.hades.dao"&gt;

    &lt;dao:dao name="user" /&gt;
    &lt;dao:dao name="role" /&gt;
  &lt;/dao:dao-config&gt;

&lt;/beans&gt;</programlisting>

          <calloutlist>
            <callout arearefs="config.dao-ns-import">
              <para>Import the dao namespace to be available in the xml
              configuraton document.</para>
            </callout>

            <callout arearefs="config.import-infrastructure">
              <para>Import infrastructure configuration.</para>
            </callout>

            <callout arearefs="config.dao-config">
              <para>Declare base packages to construct domain classes and DAO
              interfaces.</para>
            </callout>

            <callout arearefs="config.dao-instance">
              <para>Declare a single DAO instance. Each <code
              language="xml">&lt;dao:dao /&gt;</code> element will result in a
              single declaration of a
              <classname>GenericDaoFactoryBean</classname> with a domain class
              set to
              <code><code>${dao-config.entity-package-name}.${dao.name}</code></code>
              and a DAO interface set to
              <code>${dao-config.dao-package-name}.${dao.name}.${dao-config.dao-name-postfix}</code>
              where <code>dao-name-postfix</code> defaults to
              <code>Dao</code>. Given this example this will result in a
              domain class <classname>org.synyx.hades.domain.User</classname>
              and a DAO interface of
              <interfacename>org.synyx.hades.dao.UserDao</interfacename>.</para>
            </callout>
          </calloutlist>
        </programlistingco>
      </example>

      <para>This configuration replaces simple configuration mechanism
      entirely so we encourage to use this kind of configuration over the
      simple one.</para>

      <para>The <code>&lt;dao:dao-config /&gt;</code> element allows two
      further attributes to be defined. With <code>dao-name-postfix</code> you
      can customize the bean id for the DAO registered. This defaults to
      <code>Dao</code>. <code>dao-base-class</code> allows to define a custom
      base class for the DAO proxy created. For more details see <link
      linkend="vendor-specific-features">section on vendor specific
      features</link>.</para>

      <simplesect>
        <title>Auto configuration</title>

        <para>You can simplify configuration even more by adding no
        &lt;dao:dao /&gt; elements to &lt;dao:config /&gt; at all.</para>

        <example>
          <title>Automatic DAO configuration</title>

          <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:dao="http://www.synyx.de/schema/dao"
  xsi:schemaLocation="http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
    http://www.synyx.de/schema/dao 
    http://www.synyx.de/schema/dao/dao-config.xsd"&gt;

  &lt;import resource="infrastructure.xml" /&gt;

  &lt;dao:dao-config
    entity-package-name="org.synyx.hades.domain"
    dao-package-name="org.synyx.hades.dao" /&gt;

&lt;/beans&gt;</programlisting>
        </example>

        <para>This will trigger auto detection mechanism of DAOs that looks
        for entity classes implementing
        <interfacename>Persistable</interfacename> in the package you defined
        in <code>entity-package-name</code>. For each candidate found it will
        set up an DAO instances supposing you've placed the DAO interfaces in
        the configured package and named them as described above.</para>

        <note>
          <para>You have to be careful to decide for the correct DAO base
          implementation class. If one of your DAO interfaces extends
          <interfacename>ExtendedGenericDao</interfacename> (see chapter on
          using provider specific features for details) you have to define a
          matching implementation. The default implementation will cause the
          entire auto configuration to fail as it can not act as base class
          for <interfacename>ExtendedGenericDao</interfacename>.</para>
        </note>
      </simplesect>
    </section>

    <section>
      <title>Finder methods</title>

      <para>Next to standard CRUD functionality
      <classname>GenericJpaDao</classname> allows sophisticated execution of
      NamedQueries by declaring methods in the DAO interface. NamedQueries can
      be defined in either XML or JPA annotations to the domain class. Let's
      see how configuration of a query to lookup users by their email address
      can be realized.</para>

      <section>
        <title>Query lookup strategies</title>

        <para>Finders can be executed with 3 different strategies. These
        strategies define how the query for the finder is constructed at
        runtime. These strategies can either be configured at the
        <interfacename>GenericDaoFactoryBean</interfacename> directly or used
        via XML namespace configuration.</para>

        <simplesect>
          <title>CREATE</title>

          <para>This strategy will try to construct a JPA query from the
          finder method's name. Thus you don't need to declare a named query
          explicitly. This is quite useful if the queries are simple and no
          special JPA QL is required. CREATE strategy ties your mehod names to
          the query, what might be unwanted. Read more about query
          construction in <link
          linkend="finder-methods.query-creation">FOO</link>.</para>
        </simplesect>

        <simplesect>
          <title>USE_NAMED_QUERY</title>

          <para>This strategy tries to find a named query using naming
          conventions described in <link
          linkend="finder-methods.named-queries">BAR</link>. If no query is
          found the finder will fail.</para>
        </simplesect>

        <simplesect>
          <title>CREATE_IF_NOT_FOUND</title>

          <para>This strategy is actually a combination of the both mentioned
          above. It will try to lookup a named query first but create a custom
          method name based query if no named query was found. This is default
          lookup strategy and thus will be used if you don't configure
          anything explicitly. It allows quick query definition by method
          names but also custom tuning of these queries by introducing JPA
          named queries for those who need explicit tuning.</para>
        </simplesect>
      </section>

      <section id="finder-methods.query-creation">
        <title>Query creation</title>

        <para>The hades query builder mechanism is useful to build basic
        <code>WHERE</code> clauses queries. Basically you can define
        conditions on direct entity properties and concatenate them with
        <code>AND</code> and <code>OR</code>.<example>
            <title>Query creation from method names</title>

            <para><programlisting language="java">public interface UserDao&lt;User, Long&gt; {

  findByEmailAddressAndLastname(String emailAddress, String lastname);
}</programlisting>This method will result in the following query:</para>

            <programlisting>from User u where u.emailAddress = ? and u.lastname = ?</programlisting>

            <para>Besides <code>AND</code> you can use <code>OR</code> to
            concatenate property constraints. Note, that due to the lack of
            parenthesis natural binding order (<code>AND</code> binds more
            than <code>OR</code>) is used for the query.</para>
          </example></para>
      </section>

      <section id="finder-methods.named-queries">
        <title>Using JPA NamedQueries</title>

        <note>
          <para>The examples use simple <code>&lt;named-query /&gt;</code>
          element and <code>@NamedQuery</code> annotation. The queries for
          these configuration elements have to be defined in JPA query
          language. Of course you can use <code>&lt;named-native-query
          /&gt;</code> or <code>@NamedNativeQuery</code>, too. These elements
          allow you to define the query in native SQL by losing the database
          platform independence.</para>
        </note>

        <simplesect>
          <title>XML named query definition</title>

          <para>To use XML configuration simply add the necessary
          <code>&lt;named-query /&gt;</code> element to the
          <filename>orm.xml</filename> JPA configuration file located in
          <filename>META-INF</filename> folder of your classpath. Automatic
          invocation of named queries is enabled by using some defined naming
          convention. For more details see below.</para>

          <example>
            <title>XML named query configuration</title>

            <programlisting language="xml">&lt;named-query name="User.findByLastname"&gt;
  &lt;query&gt;SELECT u FROM User u WHERE u.lastname = ?1&lt;/query&gt;
&lt;/named-query&gt;</programlisting>
          </example>

          <para>As you can see the query has a special name, the
          <classname>GenericJpaDao</classname> uses to resolve it at
          runtime.</para>
        </simplesect>

        <simplesect>
          <title>Annotation configuration</title>

          <para>Annotation configuration has the advantage not to need another
          config file to be edited, probably lowering maintenance cost. You
          pay for that benefit by the need to recompile your domain class for
          every new query declaration.</para>

          <example>
            <title>Annotation based named query configuration</title>

            <programlisting language="java">@Entity
@NamedQuery(name = "User.findByEmailAddress", 
  query = "SELECT u FROM User u WHERE u.emailAddress = ?1")
public class User implements Persistable&lt;Long&gt; {

}</programlisting>
          </example>
        </simplesect>

        <simplesect>
          <title>Declaring interfaces</title>

          <para>To allow execution of this named query all you need to do is
          to specify the <interfacename>UserDao</interfacename> as
          follows:</para>

          <example>
            <title>Finder method declaration in UserDao</title>

            <programlisting language="java">public interface UserDao extends GenericDao&lt;User, Long&gt; {

  List&lt;User&gt; findByLastname(String lastname);

  User findByEmailAddress(String emailAddress);
}</programlisting>
          </example>

          <para>Declaring this method <classname>GenericJpaDao</classname>
          will try to resolve a call to this method to a named query startig
          with the simple name of the configured domain class followed by the
          method name separated by a dot. Note, that the GenericJpaDao
          implementation distinguishes between finder methods for a single
          object or lists of object. It will try to retrieve a single result
          if you provide a return value assignable from the configured domain
          class. Otherwise i will try to call a named query to return a list.
          Be sure your named query for a single instance truely returns only
          one instance.</para>
        </simplesect>
      </section>
    </section>

    <section>
      <title>Auditable entities</title>

      <para>Suppose you want to keep track of who created user entities and
      who changed them. All you need to do is implement Auditable
      interface</para>

      <example>
        <title>AuditableUser</title>

        <programlisting language="java">@Entity
public class AuditableUser implements Auditable&lt;User, Long&gt; {

  @Id
  @GeneratedValue(strategy = GenerationType.AUTO)

  private User createdUser;
  private Date createdDate;
  private User modifiedUser;
  private Date modifiedDate;

  // Getters and setters according to Auditable and 
  // Persistable omitted
}</programlisting>
      </example>

      <para>Suppose you have the following three configuration files
      <filename>infrastructure.xml</filename> (for infrastructure setup),
      <filename>audition-context.xml</filename> (to setup the audition advice)
      and <filename>dao-context.xml</filename> (for the actual DAOs) the work
      of the audition advice can be demonstrated by the following
      testcase:</para>

      <example>
        <title>Testcase for audition advice</title>

        <programlistingco>
          <areaspec>
            <area coords="1" id="audition-advice-test.superclass" />

            <area coords="8" id="audition-advice-test.reference-to-beans" />

            <area coords="13" id="audition-advice-test.test-data" />

            <area coords="23" id="audition-advice-test.setup" />

            <area coords="40" id="audition-advice-test.test-method" />
          </areaspec>

          <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(location = { "infrastructure.xml", "audition-context.xml", 
  "dao-context.xml" })
@Transactional
public class AuditionAdviceTest extends AbstractJpaTests {

  @Autowired
  private UserDao userDao;

  @Autowired
  private AuditionAdvice advice;

  private AuditableUser user;
  
  @Before
  public void setUp() {

    user = new AuditableUser();
    user.setUsername("username");
    user.setPassword("password");
    user.setEmailAddress("foo@bar.com");

    AuditorAware auditorAware = EasyMock.createNiceMock(
      AuditorAware.class);
    EasyMock.expect(auditorAware.getCurrentUser()).andReturn(
      user).anyTimes();

    advice.setAuditorAware();

    EasyMock.replay(auditorAware);
  }

  @Test
  public void testApplicationOfAuditionAdvice() {

    user = userDao.save(user);

    assertEquals(user, user.getCreatedBy());
    assertNotNull(user.getCreatonDate());

    assertEquals(user, user.getLastModifiedBy());
    assertNotNull(user.getLastModifiedDate());
  }
}</programlisting>

          <calloutlist>
            <callout arearefs="audition-advice-test.superclass">
              <para>Configure the test class to be dependency injected and
              transactional.</para>
            </callout>

            <callout arearefs="audition-advice-test.reference-to-beans">
              <para>References to Spring beans.</para>
            </callout>

            <callout arearefs="audition-advice-test.test-data">
              <para>Test user to be inserted into the database.</para>
            </callout>

            <callout arearefs="audition-advice-test.setup">
              <para>Create a dummy <classname>User</classname> instance and a
              mock <interfacename>CurrentUserAware</interfacename>, that
              always returns the dummy user. Apply this mock to the
              advice.</para>
            </callout>

            <callout arearefs="audition-advice-test.test-method">
              <para>The actual test simply saves the dummy
              <classname>User</classname> instance and verifys the advice got
              applied. Note that advice application is completely transparent
              to the client.</para>
            </callout>
          </calloutlist>
        </programlistingco>
      </example>
    </section>

    <section>
      <title>Using abstract base classes</title>

      <para>As you could see declaring the id and implementing methods defined
      in Persistable results in a lo of duplicate code. So Hades provides a
      base class that already implements the necessary methods the way shown
      above but leaves you the power to define the id type.</para>

      <para>Using AbstractPersistable would simplify User code like
      this</para>

      <example>
        <title>User based on AbstractPersistable</title>

        <programlisting language="java">@Entity
public class User extends AbstractPersistable&lt;Long&gt; {

  public static final long = 123L;

  private String username;
  private String password;
  private String emailAddress;

  @ManyToMany
  private Set&lt;Role&gt; roles;

  // Further getters and setters omitted
}</programlisting>
      </example>

      <para>Note that almost technical artefacts are gone. All methods of
      persistable are implemented by
      <classname>AbstractPersistable</classname> as well as declaration of the
      id.</para>

      <para>If you are using auditable entities
      <classname>AbstractAuditable</classname> is your base class of choice.
      This will save you from writing getters and setters for 4 class
      members</para>

      <example>
        <title>AuditableUser based on AbstractAuditable</title>

        <programlisting language="java">@Entity
public class AuditableUser extends AbstractAuditable&lt;User, Long&gt; {

  public static final long = 123L;s

  private String username;
  private String password;
  private String emailAddress;

  @ManyToMany
  private Set&lt;Role&gt; roles;
}</programlisting>
      </example>
    </section>

    <section id="vendor-specific-features">
      <title>Using vendor specific features</title>

      <para>All the functionality described until now can be used with any JPA
      persistence provider as it only relies on features specified by JPA.
      Nevertheless JPA does not include certain features like the well known
      Criteria API. As some persistence providers provide more sophisticated
      features we introduce the
      <interfacename>ExtendedGenericDao</interfacename> interface and a few
      implementations that make use of proprietary persistence provider's
      features. Thus it is your choice to use the standard JPA based
      <classname>GenericJpaDao</classname> and restrict yourself on features
      defined in the JPA spec or rely on your persistence providers extended
      features.</para>

      <para>E.g. to setup your application to use the
      <classname>GenericHibernateJpaDao</classname> you have to extend the DAO
      configuration as follows.</para>

      <example>
        <title>Configuration to use GenericHibernateJpaDao</title>

        <programlistingco>
          <areaspec>
            <area coords="4" id="hibernate-dao-config.dao-base-class" />
          </areaspec>

          <programlisting language="xml">&lt;dao:dao-config
  entity-package-name="org.synyx.hades.domain"
  dao-package-name="org.synyx.hades.dao"
  dao-base-class="org.synyx.hades.dao.orm.GenericHibernateJpaDao"&gt;

  &lt;dao:dao name="user" /&gt;
  &lt;dao:dao name="role" /&gt;
&lt;/dao:dao-config&gt;</programlisting>

          <calloutlist>
            <callout arearefs="hibernate-dao-config.dao-base-class">
              <para>Declare the specific DAO implementation in the
              <code>&lt;dao:dao-config /&gt;</code> element. This
              implementaion class has to implement at least
              <interfacename>GenericDao</interfacename> but of course only
              makes sense if the interface your specific DAO interface extends
              is also implemented by the class.</para>
            </callout>
          </calloutlist>
        </programlistingco>
      </example>
    </section>

    <section>
      <title>Custom implementations</title>

      <para>Often it is necessary to provide a custom implementation for a few
      DAO methods. Hades eases custom DAO functionality development a lot and
      allows easy integration with hades generic DAO and finder functionality.
      To enrich a generic DAO with custom functionality you have to define an
      interface and an implementation for that functionality first and let the
      DAO interface you provide by now extend that custom interface.</para>

      <example>
        <title>Interface for custom DAO functionality</title>

        <programlisting>public interface UserDaoCustom {

  public void someCustomMethod(User user);
}</programlisting>
      </example>

      <example>
        <title>Implementation of custom DAO functionality</title>

        <para><programlisting>public class UserDaoImpl implements UserDaoCustom {

  public void someCustomMethod(User user) {
    // Your custom implementation
  }
}</programlisting>Note that the implementation itself does nor depend on Hades
        and can be a regular Spring bean. So you can either use standard
        dependency injection behaviour to inject references to other beans,
        take part in aspects and so on.</para>
      </example>

      <example>
        <title>Changes to the standard DAO interface</title>

        <para><programlisting>public interface UserDao extends GenericDao&lt;User, Long&gt;, UserDaoCustom {

  // Declare finder methods here
}</programlisting>Let your standard DAO interface extend the custom one. This
        makes generic DAO and custom functionality available to
        clients.</para>
      </example>

      <simplesect>
        <title>Configuration</title>

        <para>If you use namespace configuration Hades tries to autodetect
        custom implementations by looking up classes in the configured dao
        package using the naming conventions for the DAO interface but
        appending the property <code>dao-impl-postfix</code> to the classname.
        This prefix defaults to <code>DaoImpl</code>.</para>

        <example>
          <title>Configuration example</title>

          <para><programlisting>&lt;dao:dao-config dao-package-name="foo.bar.dao" entity-package-name="foo.bar.domain"&gt;
  &lt;dao:dao id="user" /&gt;
&lt;/dao:dao-config&gt;

&lt;dao:dao-config dao-package-name="foo.bar.dao" entity-package-name="foo.bar.domain"
  &gt;
  &lt;dao:dao id="user" /&gt;
&lt;/dao:dao-config&gt;</programlisting></para>
        </example>
      </simplesect>
    </section>
  </chapter>
</book>