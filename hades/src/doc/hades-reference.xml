<?xml version="1.0" encoding="UTF-8"?>
<!-- 
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
	"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
	-->
<book>
  <bookinfo>
    <title>Hades</title>

    <subtitle>Domain class and DAO development framework</subtitle>

    <authorgroup>
      <author>
        <firstname>Oliver</firstname>

        <surname>Gierke</surname>

        <affiliation>
          <jobtitle>Software Architect</jobtitle>

          <orgname>Synyx GmbH &amp; Co. KG</orgname>
        </affiliation>

        <email>gierke@synyx.de</email>

        <address>Karlstra√üe 68, 76137 Karsruhe, Germany</address>
      </author>
    </authorgroup>

    <releaseinfo>V1.0</releaseinfo>

    <pubdate>17.10.2009</pubdate>

    <copyright>
      <year>2008-2009</year>

      <holder>Synyx GmbH &amp; Co. KG</holder>
    </copyright>

    <revhistory>
      <revision>
        <date>29.04.2008</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Initial draft</revremark>
      </revision>

      <revision>
        <date>13.05.2008</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>RC1</revremark>
      </revision>

      <revision>
        <date>13.05.2008</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>RC2 - Added auto configuration, annotation configuration
        for namespaces and finder methods for single instances</revremark>
      </revision>

      <revision>
        <date>28.10.2008</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Polished code samples a little, added appendix for
        namespace configuration</revremark>
      </revision>

      <revision>
        <date>29.11.2008</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Added documentation for EclipseLink, fixed various typos,
        XML namespace corrections</revremark>
      </revision>

      <revision>
        <date>06.12.2008</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Prepare 0.3</revremark>
      </revision>

      <revision>
        <date>26.01.2009</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Updated version and copyright date</revremark>
      </revision>

      <revision>
        <date>06.02.2009</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Added FAQ entry how to integrate Hades into existing DAO
        layer based on HibernateDaoSupport</revremark>
      </revision>

      <revision>
        <date>19.02.2009</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Added chapter on Hades Eclipse plugin, removed remarks on
        configuration of dao base class, some typos</revremark>
      </revision>

      <revision>
        <date>02.04.2009</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Preare version 0.5</revremark>
      </revision>

      <revision>
        <date>28.08.2009</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Cleaned up "finder" against "query" - relates to
        #104</revremark>
      </revision>

      <revision>
        <date>29.08.2009</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Added documentation of execution of manipulating
        queries</revremark>
      </revision>

      <revision>
        <date>17.10.2009</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Added documentation of how to use named
        parameters</revremark>
      </revision>
    </revhistory>
  </bookinfo>

  <preface>
    <title>Preface</title>

    <section>
      <title>Assumptions</title>

      <para>As Hades makes heavy use of Spring and JPA we assume you have
      certain knowledge of how to work with theses frameworks and
      specifications. Hades is implemented using some container hooks of
      Spring, AOP features. Nevetheless you do not have to have deep insight
      in conainer internals to use Hades although it would let you understand
      things more deeply.</para>
    </section>

    <section>
      <title>Technologies</title>

      <simplesect>
        <title>JPA</title>

        <para>The Java Persistence API was invented in conjunction with EJB3
        and serves as standard for persisting objects in JavaSE and JavaEE
        environments. It abstracts differences of various available OR Mappers
        like Hibernate and EclipseLink and guarantees interoperability as far
        as possible. Although the version 1.0 has its shortcomings, JPA can be
        considered a future technology.</para>
      </simplesect>

      <simplesect>
        <title>Spring</title>

        <para>Spring is the defacto standard application framework for Java
        applications. Its consistent programming model, easy configuration and
        wide support for all kinds of third party libraries makes it the first
        class citizen of application frameworks.</para>
      </simplesect>

      <simplesect>
        <title>Spring &amp; JPA</title>

        <para>Spring offers a lot of support for various technologies in data
        access area. It's main benefit regarding JPA is the ease and power of
        configuration along with proper exception translation into Spring's
        <classname>DataAccessException</classname> hierarchy.</para>
      </simplesect>
    </section>
  </preface>

  <chapter>
    <title>Core concepts</title>

    <section>
      <title>Introduction</title>

      <para>Implementing a data access layer of an application has been
      cumbersome for quite a while. To much boilerplate code had to be
      written. Domain classes were anemic and havent been designed in a real
      object oriented or domain driven manner.</para>

      <para>The last few years have brought a lot of evolution regarding those
      topics. JPA brought annotation driven persistence into Java, Spring
      established as lightweight Java development framework offering a lot of
      support especially in the area of data access.</para>

      <para>Using both of these technologies makes developers life a lot
      easier regarding rich domain model's persistence. Nevertheless the
      amount of boilerplate code especially for <glossterm>DAO</glossterm>s is
      still quite high. Besides that there is no higher level concept
      supporting you designing persistent domain classes. Hades is aiming to
      bridge that gap, providing sophisticated support for domain modeling and
      easing persistence.</para>

      <para>The following chapters will introduce the core concepts and
      interfaces of Hades roughly surrounding various steps of sophistication.
      All these step will bring significant benefit to your application but
      will introduce certain restrictions. So it's up to you to choose.</para>
    </section>

    <section>
      <title>Entities and DAOs</title>

      <para>The two central interfaces in Hades are
      <interfacename>Persistable</interfacename> and
      <interfacename>GenericDao</interfacename>. Entity defines the core
      contract for persistent domain classes that a
      <interfacename>GenericDao</interfacename> can handle.
      <interfacename>GenericDao</interfacename> itself provides sophisticated
      support for <glossterm>CRUD</glossterm> operations. Beyond that, the
      base implementation of that interface provides even more sophisticated
      features. Read more on that below.</para>

      <example>
        <title>Persistable interface</title>

        <programlisting language="java">public interface Persistable&lt;PK extends Serializable&gt; {

  public PK getId();

  public boolean isNew();

}</programlisting>
      </example>

      <para><interfacename>Persistable</interfacename>s have to be
      identifyable to be retrieved from the database. Thus your entities will
      have to provide an id or primary key. The id can be of any serializable
      type, beginning with rather simple types like
      <classname>Integer</classname> or <classname>Long</classname> up to
      complex multi column dedicated key classes. The parameterization of the
      interface will ensure typesafety on the id.</para>

      <para>The <code>isNew()</code> method is used by
      <interfacename>GenericDao</interfacename> implementations to distinguish
      a lot of operations and thus abstracting e.g. an <code>INSERT</code>
      from an <code>UPDATE</code>.</para>

      <para>Implementing <interfacename>Persistable</interfacename> will allow
      your domain class to be persisted by the default Hades
      <interfacename>GenericDao</interfacename> implementation and leaves any
      opportunity to implement certain class hierarchies to you. This freedom
      results in a few standard JPA configuration tasks you have to do
      manually. Hades provides more sophisticated base classes your entities
      can extend. This will couple your domain class code more tightly to
      Hades but frees you from implementing boilerplate JPA code.</para>

      <para>Let's take a look at the <interfacename>GenericDao</interfacename>
      interface that provides CRUD operations for entities.</para>

      <example id="example.generic-dao">
        <title>GenericDao Interface</title>

        <programlistingco>
          <areaspec>
            <area coords="4" id="generic-dao.save" />

            <area coords="6" id="generic-dao.save-and-flush" />

            <area coords="8" id="generic-dao.read-by-primary-key" />

            <area coords="10" id="generic-dao.read-all" />

            <area coords="12" id="generic-dao.read-all-pageable" />

            <area coords="14" id="generic-dao.count" />

            <area coords="16" id="generic-dao.delete" />

            <area coords="18" id="generic-dao.flush" />

            <area coords="20" id="generic-dao.exists" />
          </areaspec>

          <programlisting language="java">public interface GenericDao&lt;T extends Persistable&lt;PK&gt;, PK extends Serializable&gt;
        extends FinderExecuter&lt;T&gt; {

    T save(T persistable);

    T saveAndFlush(T persistable);

    T readByPrimaryKey(PK primaryKey);

    List&lt;T&gt; readAll();

    Page&lt;T&gt; readAll(Pageable pageable);

    Long count();

    void delete(T persistable);

    void flush();

    boolean exists(PK primaryKey);
}</programlisting>

          <calloutlist>
            <callout arearefs="generic-dao.save">
              <para>Saves the given entity.</para>
            </callout>

            <callout arearefs="generic-dao.save-and-flush">
              <para>Saves the given entity and immediately flushes changes to
              the database.</para>
            </callout>

            <callout arch="" arearefs="generic-dao.read-by-primary-key">
              <para>Returns the entity identified by the given id.</para>
            </callout>

            <callout arearefs="generic-dao.read-all">
              <para>Returns all entities.</para>
            </callout>

            <callout arch="" arearefs="generic-dao.read-all-pageable">
              <para>Returns a page of entities.</para>
            </callout>

            <callout arearefs="generic-dao.count">
              <para>Returns the number of entities.</para>
            </callout>

            <callout arearefs="generic-dao.delete">
              <para>Deletes the given entity.</para>
            </callout>

            <callout arearefs="generic-dao.flush">
              <para>Flushes pending changes to the database.</para>
            </callout>

            <callout arearefs="generic-dao.exists">
              <para>Returns whether an entity with the given id exists.</para>
            </callout>
          </calloutlist>
        </programlistingco>
      </example>

      <para>Hades provides a <classname>GenericDaoFactoryBean</classname> that
      allows setting up instances for this interface in declarative manner. So
      all you need to do is declaring an interface extending and thus typing
      the generic interface accordingly. To create DAO instances
      programatically Hades provides <classname>GenericDaoFactory</classname>.
      Read more on configuration in <xref
      linkend="sample-app.configuration" />.</para>

      <para>For more sophisticated DAO operations Hades provides
      <interfacename>ExtendedGenericDao</interfacename>. It contains
      functionality that can not be implemented with standard JPA features in
      the version 1.0. So implementations will have to rely on persistence
      providers proprietary API. Extending this interface with your concrete
      DAO interface will require to use either Hibernate or
      EclipseLink.</para>

      <example>
        <title>ExtendedGenericDao interface</title>

        <programlistingco>
          <areaspec>
            <area coords="4" id="extended-generic-dao.read-by-example" />

            <area coords="6" id="extended-generic-dao.read-by-example-sorted" />

            <area coords="8"
                  id="extended-generic-dao.read-by-example-pageable" />

            <area coords="10"
                  id="extended-generic-dao.read-by-example-pageable-sorted" />
          </areaspec>

          <programlisting language="java">public interface ExtendedGenericDao&lt;T extends Persistable&lt;PK&gt;, 
        PK extends Serializable&gt; extends GenericDao&lt;T, PK&gt; {

    List&lt;T&gt; readByExample(T... examples);

    List&lt;T&gt; readbyExample(Sort sort, T... examples);

    Page&lt;T&gt; readByExample(Pageable pageable, T... examples);

    Page&lt;T&gt; readByExample(Pageable pageable, Sort sort, T... examples);
}</programlisting>

          <calloutlist>
            <callout arearefs="extended-generic-dao.read-by-example">
              <para>Returns all entities matching the given examples. If you
              provide more that one example, their restrictions will be
              <code>OR</code> concatenated.</para>
            </callout>

            <callout arearefs="extended-generic-dao.read-by-example-pageable">
              <para>Returns all entities matching the given examples, sorted
              by the given sort option.</para>
            </callout>

            <callout arearefs="extended-generic-dao.read-by-example-pageable">
              <para>Returns a single page of the restriction result defined by
              the given example.</para>
            </callout>

            <callout arearefs="extended-generic-dao.read-by-example-pageable-sorted">
              <para>Returns a single page of the restriction result defined by
              the given example sorted by the given sort option.</para>
            </callout>
          </calloutlist>
        </programlistingco>
      </example>
    </section>

    <section>
      <title>Auditablity</title>

      <para>Most applications will require some auditability for entities
      allowing to track creation date and user and modification date and user.
      Hades provides facilities to add this audition information to entity
      transparently by AOP means. To take part in this functionality your
      domain classes have to implement a more advanced interface:</para>

      <example>
        <title><interfacename>Auditable</interfacename> interface</title>

        <programlisting language="java">public interface Auditable&lt;U extends Persistable&lt;PK&gt;, PK extends Serializable&gt;
        extends Persistable&lt;PK&gt; {

    U getCreatedBy();

    void setCreatedBy(U createdBy);

    Date getCreatedDate();

    void setCreated(Date creationDate);

    U getLastModifiedBy();

    void setLastModifiedBy(U lastModifiedBy);

    Date getLastModifiedDate();

    void setLastModified(Date lastModifiedDate);
}</programlisting>
      </example>

      <para>As you can see the modifying entity itself only has to be an
      entity. Mostly this will be some sort of User entity, so we chose U as
      parameter type.</para>

      <note>
        <para>To minimize boilerplate code Hades offers
        <classname>AbstractPersistable</classname> and
        <classname>AbstractAuditable</classname> base classes that implement
        and preconfigure entities. Thus you can decide to only implement the
        interface or enjoy more sophisticated support by extending the base
        class.</para>
      </note>

      <simplesect>
        <title><code>AuditingAdvice</code></title>

        <para>The <classname>AuditingAdvice</classname> is used to
        transparently set audition information during the work with the DAO.
        The advice gets access to the user changing or creating the entity
        through the <interfacename>AuditorAware</interfacename>
        interface.</para>

        <example>
          <title><interfacename>AuditorAware</interfacename> interface</title>

          <programlisting language="java">public interface AuditorAware&lt;T extends Persistable&lt;PK&gt;, 
  PK extends Serializable&gt; {

    T getCurrentAuditor();
}</programlisting>
        </example>

        <para>Usually you will have some kind of authentication component in
        your application that tracks the user currently working with the
        system. This component should be
        <interfacename>AuditorAware</interfacename> and thus allow seemless
        tracking of the auditor.</para>

        <para>To activate transparent creation of auditioning information the
        configuration has to look something like this:</para>

        <example>
          <title>Configuration of auditing functionality</title>

          <programlistingco>
            <areaspec>
              <area coords="9" id="auditing-advice.aop-activation" />

              <area coords="11" id="auditing-advice.audition-advice" />

              <area coords="15" id="auditing-advice.current-user-aware" />
            </areaspec>

            <programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:aop="http://www.springframework.org/schema/aop"
  xsi:schemaLocation="http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
    http://www.springframework.org/schema/aop 
    http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

  &lt;aop:aspectj-autoproxy /&gt;

  &lt;bean class="org.synyx.hades.domain.auditing.AuditingAdvice"&gt;
    &lt;property name="auditorAware" ref="auditorAware" /&gt;
  &lt;/bean&gt;

  &lt;bean id="auditorAware" class="foo.bar.AuthenticationService" /&gt;

&lt;/beans&gt;</programlisting>

            <calloutlist>
              <callout arearefs="auditing-advice.aop-activation">
                <para>Activate auto proxy creation for spring beans.</para>
              </callout>

              <callout arearefs="auditing-advice.audition-advice">
                <para>Declare the advice as spring bean and add a reference to
                the <interfacename>AuditorAware</interfacename>.</para>
              </callout>

              <callout arearefs="auditing-advice.current-user-aware">
                <para>Declare a spring bean that implements
                <interfacename>AuditorAware</interfacename>.</para>
              </callout>
            </calloutlist>
          </programlistingco>
        </example>

        <note>
          <para>By default the <classname>AuditingAdvice</classname> will use
          the current Java date as creation or modification date. If you
          prefer to use your database's capabilities to determine modification
          and creation date use <code>setDateTimeForNow(false)</code>.</para>
        </note>
      </simplesect>
    </section>
  </chapter>

  <chapter>
    <title>Sample application</title>

    <section>
      <title>Introduction</title>

      <para>In order to introduce you to working with Hades we will develop a
      small sample application managing users. As Hades is focussing on
      development of domain classes and persistence it will not be a full
      fledged application but rather concentrate on that particular part of an
      application built around the demo app.</para>

      <para>We will start by assuming that only want to have basic Hades
      support stepping forward using more sophisticated features of it.</para>

      <section>
        <title>Configuration</title>

        <para>To get started with Hades you need to setup your application in
        the standard Spring manner. The following examples leverage XML
        configuration style of the container but you could easily use other
        approaches as well. We will separate configuration into two files.
        <filename>infrastructure.xml</filename> contains a the basic
        infrastructure setup descibed in the next chapter. This one will be
        used over the various sophistication levels of Hades. Beyond that we
        will create certain further config files that contain configuration
        for various sophistication levels.</para>
      </section>
    </section>

    <section id="infrastructure">
      <title>Infrastructure</title>

      <simplesect>
        <title><interfacename>DataSource</interfacename></title>

        <para>As you might already know, Spring's data base access support is
        mainly centered around working with a
        <interfacename>DataSource</interfacename> implementation. Although you
        should rely on more sophisticated
        <interfacename>DataSource</interfacename> implementations like Commons
        DBCP, Spring comes with <classname>DriverManagerDataSource</classname>
        out of the box that should be satisfying for testing purposes.</para>

        <note>
          <para>Environment specific configuration that highly varies between
          deployments should not be hardcoded into a Spring configuration
          file. Preferably, use a
          <classname>PropertyPlaceholderConfigurer</classname><footnote>
              <para>For more information see <ulink
              url="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-factory-placeholderconfigurer">Spring's
              reference documentation</ulink> on that topic</para>
            </footnote> to externalize those kinds of settings into an
          external properties file that can easily customized by application
          administrators.</para>
        </note>

        <para>So we setup an instance of it in typical Spring Dependency
        Injection manner.</para>

        <example>
          <title>DataSource configuration</title>

          <programlistingco>
            <areaspec>
              <area coords="3" id="data-source.driver-class-name" />

              <area coords="4" id="data-source.url" />

              <area coords="5" id="data-source.username" />

              <area coords="6" id="data-source.password" />
            </areaspec>

            <programlisting language="xml">&lt;bean id="dataSource" 
  class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
  &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt;
  &lt;property name="url" value="jdbc:mysql://localhost:3306/hades" /&gt;
  &lt;property name="username" value="username" /&gt;
  &lt;property name="password" value="password" /&gt;
&lt;/bean&gt;</programlisting>

            <calloutlist>
              <callout arearefs="data-source.driver-class-name">
                <para>Configure your database vendor's specific driver
                class</para>
              </callout>

              <callout arearefs="data-source.url">
                <para>Point the data source to your database's location</para>
              </callout>

              <callout arearefs="data-source.username data-source.password">
                <para>Authentication credentials</para>
              </callout>
            </calloutlist>
          </programlistingco>
        </example>
      </simplesect>

      <simplesect id="infrastructure.entity-manager-factory">
        <title><interfacename>EntityManager</interfacename>(<interfacename>Factory</interfacename>)</title>

        <example>
          <title><interfacename>EntityManager</interfacename>
          configuration</title>

          <programlistingco>
            <areaspec>
              <area coords="3" id="entity-manager-factory.data-source" />

              <area coords="4" id="entity-manager-factory.jpa-vendor-adapter" />
            </areaspec>

            <programlisting language="xml">&lt;bean id="entityManagerFactory"
  class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="dataSource" ref="dataSource" /&gt;
  &lt;property name="jpaVendorAdapter"&gt;
    &lt;bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"&gt;
      &lt;property name="showSql" value="true" /&gt;
      &lt;property name="generateDdl" value="true" /&gt;
      &lt;property name="database" value="MYSQL" /&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

            <calloutlist>
              <callout arearefs="entity-manager-factory.data-source">
                <para>Reference the DataSource declared before</para>
              </callout>

              <callout arearefs="entity-manager-factory.jpa-vendor-adapter">
                <para>Apply a vendor specific adapter to add further
                configuration. In this case we use Hibernate and tell it to
                use MySQL dialect for accessing the database, generate the
                required database tables as needed and log SQL queries fired
                to the database</para>
              </callout>
            </calloutlist>
          </programlistingco>
        </example>
      </simplesect>

      <simplesect>
        <title>Transaction management</title>

        <para>Spring leverages consistent transaction abstraction through its
        <interfacename>PlatformTransactionManager</interfacename> interface
        and provides a <classname>JpaTransactionManager</classname>
        implementation out of the box.</para>

        <example>
          <title>Transaction manager configuration</title>

          <programlisting language="xml">&lt;bean id="transactionManager"
  class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
  &lt;property name="entityManagerFactory" ref="entityManagerFactory" /&gt;
&lt;/bean&gt;</programlisting>
        </example>
      </simplesect>

      <simplesect>
        <title>BeanPostProcessors</title>

        <para>As Hades leverages Spring 2.5 annotations to activate exception
        translation and injecting <interfacename>EntityManager</interfacename>
        instances we need to configure 2
        <interfacename>BeanPostProcessor</interfacename>s.</para>

        <example>
          <title>BeanPostProcessor configuration</title>

          <programlisting language="xml">&lt;bean
  class="org...PersistenceAnnotationBeanPostProcessor" /&gt;

&lt;bean
  class="org...PersistenceExceptionTranslationPostProcessor" /&gt;</programlisting>
        </example>
      </simplesect>
    </section>

    <section>
      <title>Basic entities and DAOs</title>

      <para>Now we are going to create the entities and DAOs needed to manage
      users with roles. Note that we will start with an implementation with
      the least possible coupling to Hades. The will force us to configure a
      few things ourselves but decrease dependencies. If you want to know, how
      you can ease things a little more see <xref
      linkend="sample-app.base-classes" /> and <xref
      linkend="sample-app.namespace" />.</para>

      <section>
        <title>Users and roles</title>

        <para>As we want to create a small user management application, the
        primary entities we will deal with are <classname>User</classname> and
        <classname>Role</classname>. Take a look at the code snippets:</para>

        <example>
          <title><classname>User</classname> entity</title>

          <programlisting language="java">@Entity
public class User implements Persistable&lt;Long&gt; {

  public static final long serialVersionUID = 123L

  @Id
  @GeneratedValue(strategy = GenerationType.AUTO)
  private Long id;
  private String username;
  private String password;
  private String emailAddress;

  @ManyToMany
  private Set&lt;Role&gt; roles;

  public Long getId() {
    return this.id;
  }

  // Further getters and setters omitted

  public boolean isNew() {
    return null == this.id;
  }
}</programlisting>
        </example>

        <para>Note that we decide to have an id type of
        <classname>Long</classname>. We have to add annotations for the id
        ourselves and implement <methodname>isNew()</methodname> manually,
        too. We create a many-to-many relationship to the <code>Role</code>
        class and store some string values like username, password and email
        address.</para>

        <example>
          <title><classname>Role</classname> entity</title>

          <programlisting language="java">@Entity
public class Role implements Persistable&lt;Integer&gt; {

  private static final long serialVersionUID = -123L;

  @Id
  @GeneratedValue(strategy = GenerationType.AUTO)
  private Integer id;
  private String name;

  public Integer getId() {
    return this.id;
  }

  // Further getters and setters omitted

  public boolean isNew() {
    return null == this.id;
  }
}</programlisting>
        </example>

        <para>The <classname>Role</classname> class looks quite similar. Note
        that we decide for an alternate id type. So mixing id type is no
        problem at all.</para>
      </section>

      <section>
        <title>DAOs</title>

        <para>As we have modeled the entities we need to add an interface for
        a DAO handling persistence operations for them:</para>

        <example>
          <title>UserDao and RoleDao interface</title>

          <programlisting language="java">public interface UserDao extends GenericDao&lt;User, Long&gt; {
}</programlisting>

          <programlisting language="java">public interface RoleDao extends GenericDao&lt;Role, Integer&gt; {
}</programlisting>

          <para>As you can see the interfaces serve typing purposes only for
          now. We will add further functionality to them later.
          <interfacename>GenericDao</interfacename> provides most of the
          required persistence operations. Hades provides various
          implementations of this interface so that you don't need to code one
          on your own.</para>
        </example>
      </section>

      <section id="sample-app.configuration">
        <title>Configuration</title>

        <para><classname>GenericJpaDao</classname> is the base implementation
        of <interfacename>GenericDao</interfacename> that serves basic
        purposes very well. It uses Spring's exception translation and entity
        manager injection facilities so that its creation logic is
        encapsulated into <classname>GenericDaoFactoryBean</classname>. So the
        basic configuration for a DAO instance looks as follows:</para>

        <example>
          <title>Simple DAO configuration</title>

          <programlistingco>
            <areaspec>
              <area coords="1" id="simple-dao-config.infrastructure-import" />

              <area coords="6" id="simple-dao-config.dao-interface" />
            </areaspec>

            <programlisting language="xml">&lt;import resource="infrastructure.xml" /&gt;

&lt;bean id="userDao" 
    class="org.synyx.hades.dao.orm.support.GenericDaoFactoryBean"&gt;
  &lt;property name="daoInterface" value="org.synyx.hades.dao.UserDao" /&gt;
&lt;/bean&gt;

&lt;bean id="roleDao"
    class="org.synyx.hades.dao.orm.support.GenericDaoFactoryBean"&gt;
  &lt;property name="daoInterface" value="org.synyx.hades.dao.RoleDao" /&gt;
&lt;/bean&gt;</programlisting>

            <calloutlist>
              <callout arearefs="simple-dao-config.infrastructure-import">
                <para>Import infrastructure configuration. Supposed we have
                combined the configuration examples shown in <xref
                linkend="infrastructure" /> into a file named
                <filename>infrastructure.xml</filename></para>
              </callout>

              <callout arearefs="simple-dao-config.dao-interface">
                <para>Declare the DAO interface you want to expose. This
                interface has to extend
                <interfacename>GenericDao</interfacename>.</para>
              </callout>
            </calloutlist>
          </programlistingco>
        </example>

        <para>This is smallest standard XML configuration possible. There are
        a lot more options on GenericDaoFactoryBean, but you rather choose XML
        namespace configuration due to less verbosity.</para>
      </section>

      <section>
        <title>Client code</title>

        <para>The previously declared <interfacename>UserDao</interfacename>
        can be accessed via its bean id from the
        <interfacename>ApplicationContext</interfacename>, although you
        definately are better off letting the container inject it into you
        client:</para>

        <example>
          <title>Manual lookup of UserDao</title>

          <programlisting language="java">ApplicationContext ctx = new ClasspathXmlApplicationContext(
  "applicationContext.xml");
UserDao userDao = (UserDao) ctx.getBean("userDao");

User user = userDao.readByPrimaryKey(1L);</programlisting>
        </example>
      </section>
    </section>

    <section id="sample-app.namespace">
      <title>Easing configuration - Spring namespaces</title>

      <para>Configuring DAOs the standard way can become cumbersome if your
      application requires a lot of DAOs. With help of Spring 2.5 namespaces
      there is a more sophisticated way to configure them.</para>

      <example>
        <title>DAO configuration with Spring namespaces</title>

        <programlistingco>
          <areaspec>
            <area coords="4" id="config.dao-ns-import" />

            <area coords="7" id="config.dao-ns-location" />

            <area coords="10" id="config.import-infrastructure" />

            <area coords="12" id="config.dao-config" />

            <area coords="13" id="config.dao-instance" />
          </areaspec>

          <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:hades="http://schemas.synyx.org/hades"
  xsi:schemaLocation="http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
    http://schemas.synyx.org/hades
    http://schemas.synyx.org/hades/hades.xsd"&gt;

  &lt;import resource="infrastructure.xml" /&gt;

  &lt;hades:dao-config base-package="org.synyx.hades.dao"&gt;
    &lt;hades:dao id="userDao" /&gt;
    &lt;hades:dao id="roleDao" /&gt;
  &lt;/hades:dao-config&gt;

&lt;/beans&gt;</programlisting>

          <calloutlist>
            <callout arearefs="config.dao-ns-import config.dao-ns-location">
              <para>Import the dao namespace to be available in the xml
              configuraton document.</para>
            </callout>

            <callout arearefs="config.import-infrastructure">
              <para>Import infrastructure configuration.</para>
            </callout>

            <callout arearefs="config.dao-config">
              <para>Declare base packages to construct domain classes and DAO
              interfaces.</para>
            </callout>

            <callout arearefs="config.dao-instance">
              <para>Declare a single DAO instance. Each <code
              language="xml">&lt;dao /&gt;</code> element will result in a
              single declaration of a
              <classname>GenericDaoFactoryBean</classname> with a DAO
              interface set to
              <code>${dao-config.base-package}.${dao.id}</code>. Given this
              example this will result in a DAO interface of
              <interfacename>org.synyx.hades.dao.UserDao</interfacename>
              registered under <code>userDao</code>.</para>
            </callout>
          </calloutlist>
        </programlistingco>
      </example>

      <para>This configuration replaces simple configuration mechanism
      entirely so we encourage to use this kind of configuration over the
      simple one.</para>

      <para>The <code>&lt;dao-config /&gt;</code> element allows two further
      attributes to be defined. With <code>dao-name-postfix</code> you can
      customize the bean id for the DAO registered. This defaults to
      <code>Dao</code>.</para>

      <simplesect id="config.autoconfig">
        <title>Auto configuration</title>

        <para>You can simplify configuration even more by adding no
        <code>&lt;dao /&gt;</code> elements to <code>&lt;dao-config
        /&gt;</code> at all.</para>

        <example>
          <title>Automatic DAO configuration</title>

          <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:hades="http://schemas.synyx.org/hades"
  xsi:schemaLocation="http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
    http://schemas.synyx.org/hades 
    http://schemas.synyx.org/hades/hades.xsd"&gt;

  &lt;import resource="infrastructure.xml" /&gt;

  &lt;hades:dao-config base-package="org.synyx.hades.dao" /&gt;

&lt;/beans&gt;</programlisting>
        </example>

        <para>This will trigger auto detection mechanism of DAOs that extend
        <interfacename>GenericDao</interfacename> or
        <interfacename>ExtendedGenericDao</interfacename>. For each candidate
        found it will set up an DAO instances supposing you've placed the DAO
        interfaces in the configured package and named them as described
        above</para>
      </simplesect>
    </section>

    <section id="finder-methods">
      <title>Query methods</title>

      <para>Next to standard CRUD functionality
      <classname>GenericJpaDao</classname> allows sophisticated execution of
      queries by declaring methods in the DAO interface. Let's see how
      configuration of a query to lookup users by their email address can be
      realized.</para>

      <section id="sample-app.finders.strategies">
        <title>Query lookup strategies</title>

        <para>Queries can be executed with 3 different strategies. These
        strategies define how the JPA query is constructed at runtime. These
        strategies can either be configured at the
        <interfacename>GenericDaoFactoryBean</interfacename> directly or used
        via XML namespace configuration.</para>

        <simplesect>
          <title>CREATE</title>

          <para>This strategy will try to construct a JPA query from the query
          method's name. Thus you don't need to declare a named query
          explicitly. This is quite useful if the queries are simple and no
          special JPA QL is required. <code>CREATE</code> strategy ties your
          mehod names to the query, what might be unwanted. Read more about
          query construction in <xref
          linkend="finder-methods.query-creation" />.</para>
        </simplesect>

        <simplesect>
          <title>USE_DECLARED_QUERY</title>

          <para>This strategy tries to find a declared query that can either
          be defined using JPA <code>@NamedQuery</code> means or Hades
          <code>@Query</code> annotation (see <xref
          linkend="finder-methods.named-queries" /> and <xref
          linkend="finder-methods.at-query" /> for details). If no declared
          query is found execution of the query will fail.</para>
        </simplesect>

        <simplesect>
          <title>CREATE_IF_NOT_FOUND</title>

          <para>This strategy is actually a combination of the both mentioned
          above. It will try to lookup a declared query first but create a
          custom method name based query if no named query was found. This is
          default lookup strategy and thus will be used if you don't configure
          anything explicitly. It allows quick query definition by method
          names but also custom tuning of these queries by introducing
          declared queries for those who need explicit tuning.</para>
        </simplesect>
      </section>

      <section id="finder-methods.query-creation">
        <title>Query creation</title>

        <para>The hades query builder mechanism is useful to build basic
        <code>WHERE</code> clauses queries. Hades will directly translate the
        method name into a where clause. Basically you can define conditions
        on direct entity properties and concatenate them with <code>AND</code>
        and <code>OR</code>.<example>
            <title>Query creation from method names</title>

            <para><programlisting language="java">public interface UserDao extends GenericDao&lt;User, Long&gt; {

  findByEmailAddressAndLastname(String emailAddress, String lastname);
}</programlisting>This method will result in the following query:</para>

            <programlisting>from User u where u.emailAddress = ? and u.lastname = ?</programlisting>

            <para>Hades will check the query against the domain class to
            validate the properties exist. So you either have a property of
            the appropriate name or a getter method. Furthermore Hades will
            strip a list of prefixes from the method name before translating
            it into a query. The prefixes are: <code>findBy</code>,
            <code>find</code>, <code>readBy</code>, <code>read</code>,
            <code>getBy</code> as well as <code>get</code>. Besides
            <code>AND</code> you can use <code>OR</code> to concatenate
            property constraints. Note, that due to the lack of parenthesis
            natural binding order (<code>AND</code> binds more than
            <code>OR</code>) is used for the query.</para>
          </example></para>
      </section>

      <section id="finder-methods.named-queries">
        <title>Using JPA NamedQueries</title>

        <note>
          <para>The examples use simple <code>&lt;named-query /&gt;</code>
          element and <code>@NamedQuery</code> annotation. The queries for
          these configuration elements have to be defined in JPA query
          language. Of course you can use <code>&lt;named-native-query
          /&gt;</code> or <code>@NamedNativeQuery</code>, too. These elements
          allow you to define the query in native SQL by losing the database
          platform independence.</para>
        </note>

        <simplesect>
          <title>XML named query definition</title>

          <para>To use XML configuration simply add the necessary
          <code>&lt;named-query /&gt;</code> element to the
          <filename>orm.xml</filename> JPA configuration file located in
          <filename>META-INF</filename> folder of your classpath. Automatic
          invocation of named queries is enabled by using some defined naming
          convention. For more details see below.</para>

          <example>
            <title>XML named query configuration</title>

            <programlisting language="xml">&lt;named-query name="User.findByLastname"&gt;
  &lt;query&gt;FROM User u WHERE u.lastname = ?1&lt;/query&gt;
&lt;/named-query&gt;</programlisting>
          </example>

          <para>As you can see the query has a special name, the
          <classname>GenericJpaDao</classname> uses to resolve it at
          runtime.</para>
        </simplesect>

        <simplesect>
          <title>Annotation configuration</title>

          <para>Annotation configuration has the advantage not to need another
          config file to be edited, probably lowering maintenance cost. You
          pay for that benefit by the need to recompile your domain class for
          every new query declaration.</para>

          <example>
            <title>Annotation based named query configuration</title>

            <programlisting language="java">@Entity
@NamedQuery(name = "User.findByEmailAddress", 
  query = "FROM User u WHERE u.emailAddress = ?1")
public class User implements Persistable&lt;Long&gt; {

}</programlisting>
          </example>
        </simplesect>

        <simplesect>
          <title>Declaring interfaces</title>

          <para>To allow execution of this named query all you need to do is
          to specify the <interfacename>UserDao</interfacename> as
          follows:</para>

          <example>
            <title>Query method declaration in UserDao</title>

            <programlisting language="java">public interface UserDao extends GenericDao&lt;User, Long&gt; {

  List&lt;User&gt; findByLastname(String lastname);

  User findByEmailAddress(String emailAddress);
}</programlisting>
          </example>

          <para>Declaring this method <classname>GenericJpaDao</classname>
          will try to resolve a call to this method to a named query starting
          with the simple name of the configured domain class followed by the
          method name separated by a dot. Note, that Hadesdistinguishes
          between query methods for a single object or lists of object. It
          will try to retrieve a single result if you provide a return value
          assignable from the configured domain class. Otherwise i will try to
          call a named query to return a list. Be sure your named query for a
          single instance truely returns only one instance.</para>
        </simplesect>
      </section>

      <section id="finder-methods.at-query">
        <title>Using @Query</title>

        <para>Using named queries to declare queries for entities is a valid
        approach and works fine for a small number amount of queries. As the
        queries themselves are tied to a Java method to execute them you
        actually can bind them to the query executing methods using Hades
        <code>@Query</code> annotation rather than annotating them to the
        domain class. This will free the domain class from persistence
        specific information and colocate it to the DAO interface.</para>

        <para>Querys annotated to the query method will trump queries defined
        using <code>@NamedQuery</code> or named queries declared in in
        <filename>orm.xml</filename>.</para>

        <example>
          <title>Declare query at the query method using @Query</title>

          <programlisting language="java">public interface UserDao extends GenericDao&lt;User, Long&gt; {

  @Query("FROM User u WHERE u.emailAddress = ?1")
  User findByEmailAddress(String emailAddress);
}</programlisting>
        </example>
      </section>

      <section>
        <title>Using named parameters</title>

        <para>By default Hades will use position based parameter binding as
        described in all the samples above. This makes query methods a little
        error prone to refactorngs regarding the parameter position. To solve
        this issue you can use <code>@Param</code> annotation to give a method
        parameter a cncrete name and bind the name in the query:</para>

        <example>
          <title>Using named parameters</title>

          <programlisting language="java">public interface UserDao extends GenericDao&lt;User, Long&gt; {

  @Query("FROM User u WHERE u.firstname = :firstname or u.lastname = :lastname")
  User findByLastnameOrFirstname(@Param("lastname") String lastname
                                 @Param("firstname") String firstname;
}</programlisting>

          <para>Note that the method parameters are switched according to the
          occurrence in the query defined.</para>
        </example>
      </section>

      <section>
        <title>Special parameter handling</title>

        <para>To hand parameters to your query you simply define method
        parameters as already seen in in examples above. Besides that Hades
        recognizes certain Hades specific types to apply pagination and
        sorting to your queries dynamically.</para>

        <example>
          <title>Using Pageable and Sort in query methods</title>

          <para><programlisting>Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);

List&lt;User&gt; findByLastname(String lastname, Sort sort);</programlisting>The
          first method allows you to pass a <code>Pageable</code> instance to
          the query method to dynamically add paging to your statically
          defined query. <code>Sorting</code> options are handed via the
          Pageable instance, too. If you only need sorting, simply add a
          <code>Sort</code> parameter to your method.</para>
        </example>
      </section>

      <section>
        <title>Modifying queries</title>

        <para>All the sections before described how to declare queries to
        access a given entity or collection of entitites. Of course you can
        add custom modifying behaviour by using facilities described in <xref
        linkend="custom-implementations" />. As this approach is feasible for
        comprehensive custom functionality, you can achieve the execution of
        modifying queries that actually only need parameter binding by
        annotating the query method with <code>@Modifying</code>:</para>

        <example>
          <title>Declaring manipulating queries</title>

          <programlisting>@Modifying
@Query("update User u set u.firstname = ?1 where u.lastname = ?2")
Long setFixedFirstnameFor(String firstname, String lastname);</programlisting>
        </example>

        <para>This will trigger the query annotated to the method as updating
        query instead of a selecting one.</para>
      </section>
    </section>

    <section>
      <title>Auditable entities</title>

      <para>Suppose you want to keep track of who created user entities and
      who changed them. All you need to do is implement
      <interfacename>Auditable</interfacename> interface</para>

      <example>
        <title>AuditableUser</title>

        <programlisting language="java">@Entity
public class AuditableUser implements Auditable&lt;User, Long&gt; {

  @Id
  @GeneratedValue(strategy = GenerationType.AUTO)
  private Long id;

  private User createdUser;
  private Date createdDate;
  private User modifiedUser;
  private Date modifiedDate;

  // Getters and setters according to Auditable and 
  // Persistable omitted
}</programlisting>
      </example>

      <para>Suppose you have the following three configuration files
      <filename>infrastructure.xml</filename> (for infrastructure setup),
      <filename>audition-context.xml</filename> (to setup the audition advice)
      and <filename>dao-context.xml</filename> (for the actual DAOs) the work
      of the <classname>AuditingAdvice</classname> can be demonstrated by the
      following testcase:</para>

      <example>
        <title>Testcase for <classname>AuditingAdvice</classname></title>

        <programlistingco>
          <areaspec>
            <area coords="1" id="auditing-advice-test.superclass" />

            <area coords="8" id="auditing-advice-test.reference-to-beans" />

            <area coords="13" id="auditing-advice-test.test-data" />

            <area coords="23" id="auditing-advice-test.setup" />

            <area coords="40" id="auditing-advice-test.test-method" />
          </areaspec>

          <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(location = { "infrastructure.xml", 
  "audition-context.xml", "dao-context.xml" })
@Transactional
public class AuditionAdviceTest extends AbstractJpaTests {

  @Autowired
  private UserDao userDao;

  @Autowired
  private AuditionAdvice advice;

  private AuditableUser user;
  
  @Before
  public void setUp() {

    user = new AuditableUser();
    user.setUsername("username");
    user.setPassword("password");
    user.setEmailAddress("foo@bar.com");

    AuditorAware auditorAware = EasyMock.createNiceMock(
      AuditorAware.class);
    EasyMock.expect(auditorAware.getCurrentUser()).andReturn(
      user).anyTimes();

    advice.setAuditorAware();

    EasyMock.replay(auditorAware);
  }

  @Test
  public void testApplicationOfAuditionAdvice() {

    user = userDao.save(user);

    assertEquals(user, user.getCreatedBy());
    assertNotNull(user.getCreatonDate());

    assertEquals(user, user.getLastModifiedBy());
    assertNotNull(user.getLastModifiedDate());
  }
}</programlisting>

          <calloutlist>
            <callout arearefs="auditing-advice-test.superclass">
              <para>Configure the test class to be dependency injected and
              transactional.</para>
            </callout>

            <callout arearefs="auditing-advice-test.reference-to-beans">
              <para>References to Spring beans.</para>
            </callout>

            <callout arearefs="auditing-advice-test.test-data">
              <para>Test user to be inserted into the database.</para>
            </callout>

            <callout arearefs="auditing-advice-test.setup">
              <para>Create a dummy <classname>User</classname> instance and a
              mock <interfacename>CurrentUserAware</interfacename>, that
              always returns the dummy user. Apply this mock to the
              advice.</para>
            </callout>

            <callout arearefs="auditing-advice-test.test-method">
              <para>The actual test simply saves the dummy
              <classname>User</classname> instance and verifys the advice got
              applied. Note that advice application is completely transparent
              to the client.</para>
            </callout>
          </calloutlist>
        </programlistingco>
      </example>
    </section>

    <section id="sample-app.base-classes">
      <title>Using abstract base classes</title>

      <para>As you could see declaring the id and implementing methods defined
      in Persistable results in a lo of duplicate code. So Hades provides a
      base class that already implements the necessary methods the way shown
      above but leaves you the power to define the id type.</para>

      <para>Using <classname>AbstractPersistable</classname> would simplify
      User code like this</para>

      <example>
        <title>User based on
        <classname>AbstractPersistable</classname></title>

        <programlisting language="java">@Entity
public class User extends AbstractPersistable&lt;Long&gt; {

  public static final long = 123L;

  private String username;
  private String password;
  private String emailAddress;

  @ManyToMany
  private Set&lt;Role&gt; roles;

  // Further getters and setters omitted
}</programlisting>
      </example>

      <para>Note that almost technical artefacts are gone. All methods of
      persistable are implemented by
      <classname>AbstractPersistable</classname> as well as declaration of the
      id.</para>

      <para>If you are using auditable entities
      <classname>AbstractAuditable</classname> is your base class of choice.
      This will save you from writing getters and setters for 4 class
      members</para>

      <example>
        <title><classname>AuditableUser</classname> based on
        <classname>AbstractAuditable</classname></title>

        <programlisting language="java">@Entity
public class AuditableUser extends AbstractAuditable&lt;User, Long&gt; {

  public static final long = 123L;s

  private String username;
  private String password;
  private String emailAddress;

  @ManyToMany
  private Set&lt;Role&gt; roles;
}</programlisting>
      </example>
    </section>

    <section id="vendor-specific-features">
      <title>Using vendor specific features</title>

      <para>All the functionality described until now can be used with any JPA
      persistence provider as it only relies on features specified by JPA.
      Nevertheless JPA does not include certain features like the well known
      criteria API. As some persistence providers provide more sophisticated
      features we introduce the
      <interfacename>ExtendedGenericDao</interfacename> interface and a few
      implementations that make use of proprietary persistence provider's
      features. Thus it is your choice to use the standard JPA based
      <classname>GenericJpaDao</classname> and restrict yourself on features
      defined in the JPA spec or rely on your persistence providers extended
      features.</para>

      <para>Currently Hades provides implementations for
      <interfacename>ExtendedGenericDao</interfacename> based on Hibernate and
      EclipseLink. Note, that you can use basic DAO functionality with
      <emphasis>any</emphasis> JPA persistence provider.</para>

      <note>
        <para>Starting with version 0.4 Hades is able to detect the
        persistence provider you chose itself. So there is no need to
        configure it explicitly. It will be able to use the appropriate types
        to back the DAO proxy itself if you use either Hibernate or
        EclipseLink. For any other persistence provider it will fall back on
        <code>GenericJpaDao</code>, that does not provide the extended DAO
        functionality listed in <code>ExtendedGenericDao</code>. If you try to
        create DAO instances for DAO interfaces extending
        <code>ExtendedGenericDao</code> but use OpenJPA e.g. Hades will
        complain at configuration time.</para>
      </note>

      <para>E.g. to setup your application to use the
      <classname>GenericHibernateJpaDao</classname> you have to extend the DAO
      configuration as follows.</para>

      <example>
        <title>Configuration to use
        <classname>GenericHibernateJpaDao</classname></title>

        <programlistingco>
          <areaspec>
            <area coords="4" id="hibernate-dao-config.dao-base-class" />
          </areaspec>

          <programlisting language="xml">&lt;dao-config base-package="org.synyx.hades.dao"&gt;
  &lt;dao name="userDao" /&gt;
  &lt;dao name="roleDao" /&gt;
&lt;/dao-config&gt;</programlisting>

          <calloutlist>
            <callout arearefs="hibernate-dao-config.dao-base-class">
              <para>Declare the specific DAO implementation in the
              <code>&lt;dao-config /&gt;</code> element. This implementaion
              class has to implement at least
              <interfacename>GenericDao</interfacename> but of course only
              makes sense if the interface your specific DAO interface extends
              is also implemented by the class.</para>
            </callout>
          </calloutlist>
        </programlistingco>
      </example>

      <note>
        <para>Using EclipseLink as a persistence provider you will have to
        activate load time weaving for your application. Furthermore there is
        a <ulink
        url="https://bugs.eclipse.org/bugs/show_bug.cgi?id=240618">known
        bug</ulink> regarding combination of EclipseLink and HSQL you should
        be aware of. With <classname>EclipseLinkHSQLPLatform</classname> Hades
        provides a workaround for this. See the
        <filename>eclipselink.xml</filename> configuration file in the test
        directory for details.</para>
      </note>
    </section>

    <section id="custom-implementations">
      <title>Custom implementations</title>

      <para>Often it is necessary to provide a custom implementation for a few
      DAO methods. Hades eases custom DAO functionality development a lot and
      allows easy integration with hades generic DAO and query method
      functionality. To enrich a generic DAO with custom functionality you
      have to define an interface and an implementation for that functionality
      first and let the DAO interface you provide by now extend that custom
      interface.</para>

      <example>
        <title>Interface for custom DAO functionality</title>

        <programlisting language="java">public interface UserDaoCustom {

  public void someCustomMethod(User user);
}</programlisting>
      </example>

      <example>
        <title>Implementation of custom DAO functionality</title>

        <para><programlisting language="java">public class UserDaoImpl implements UserDaoCustom {

  public void someCustomMethod(User user) {
    // Your custom implementation
  }
}</programlisting>Note that the implementation itself does not depend on Hades
        and can be a regular Spring bean. So you can either use standard
        dependency injection behaviour to inject references to other beans,
        take part in aspects and so on.</para>
      </example>

      <example>
        <title>Changes to the standard DAO interface</title>

        <para><programlisting language="java">public interface UserDao extends GenericDao&lt;User, Long&gt;, UserDaoCustom {

  // Declare query methods here
}</programlisting>Let your standard DAO interface extend the custom one. This
        makes generic DAO and custom functionality available to
        clients.</para>
      </example>

      <simplesect>
        <title>Configuration</title>

        <para>If you use namespace configuration Hades tries to autodetect
        custom implementations by looking up classes in the configured dao
        package using the naming conventions for the DAO interface but
        appending the property <code>dao-impl-postfix</code> to the classname.
        This prefix defaults to <code>DaoImpl</code>.</para>

        <example>
          <title>Configuration example</title>

          <para><programlisting language="xml">&lt;dao-config base-package="foo.bar.dao"&gt;
  &lt;dao id="userDao" /&gt;
&lt;/dao-config&gt;

&lt;dao-config base-package="foo.bar.dao" dao-impl-postfix="FooBar"&gt;
  &lt;dao id="userDao" /&gt;
&lt;/dao-config&gt;</programlisting></para>
        </example>

        <para>The first configuration example will try to lookup a class
        <classname>foo.bar.dao.UserDaoImpl</classname> to act as custom DAO
        implementation, where the second example will try to lookup
        <classname>foo.bar.dao.UserDaoFooBar</classname>.</para>
      </simplesect>

      <simplesect>
        <title>Manual wiring</title>

        <para>The approach above works perfectly well if your custom
        implementation uses annotation based configuration and autowring
        entirely as will be trated as any other Spring bean. If your customly
        implemented bean needs some special wiring you simply declare the bean
        and name it after the conventions just descibed. Hades will the pick
        up the custom bean by name rather than creating an own
        instance.</para>

        <example>
          <title>Manual wiring of custom implementations (I)</title>

          <programlisting language="xml">&lt;dao-config base-package="foo.bar.dao"&gt;
  &lt;dao id="userDao" /&gt;
&lt;/dao-config&gt;

&lt;bean id="userDaoImpl" class="..."&gt;
  &lt;!-- further configuration --&gt;
&lt;/bean&gt;</programlisting>

          <para>This also works if you use automatic DAO lookup without
          defining single <code>&lt;dao /&gt;</code> elements.</para>
        </example>

        <para>In case you are not in control of the implementation bean name
        (e.g. if you wrap a generic dao facade around an existing DAO
        implementation) you can explicitly tell the <code>&lt;dao /&gt;</code>
        element which bean to use as custom implementation by using the
        dao-impl-ref attribute.</para>

        <example>
          <title>Manual wiring of custom implementations (II)</title>

          <para><programlisting language="xml">&lt;dao-config base-package="foo.bar.dao"&gt;
  &lt;dao id="userDao" dao-impl-ref="customDaoImplementation" /&gt;
&lt;/dao-config&gt;

&lt;bean id="customDaoImplementation" class="..."&gt;
  &lt;!-- further configuration --&gt;
&lt;/bean&gt;</programlisting></para>
        </example>
      </simplesect>
    </section>
  </chapter>

  <chapter>
    <title>Eclipse plugin</title>

    <abstract>
      <para>To tightly integrate Hades into your application it is useful to
      leverage the features provided by Spring IDE. You can achieve this using
      the Hades Eclipse plugin. This chapter explains in detail how to install
      the plugin and what features you can expect by it.</para>
    </abstract>

    <section>
      <title>Installation</title>

      <para>You can install the plugin by simply pointing your Eclipse update
      manager to <ulink
      url="http://updatesite.synyx.org">http://updatesite.synyx.org</ulink>
      and choosing the Hades Namespace Integration.</para>
    </section>

    <section>
      <title>Features</title>

      <simplesect>
        <title>Code completion for XML elements attributes</title>

        <para>By handing over the Hades XSD you gain code completion for XML
        elements and especially attributes. This regards
        <code>base-package</code> in particular as well as the
        custom-element-ref attribute in the &lt;dao /&gt; element.</para>
      </simplesect>

      <simplesect>
        <title>Beans detection using automatic dao detection mode</title>

        <para>If you use the automatic DAO detection mode as shown in <xref
        linkend="hades-xml-editor" /> you will get all discovered DAO beans
        correctly listed in the Spring Elements section of your Project
        Explorer. The beans also lists property values like the query lookup
        strategy including implicit defaults.</para>
      </simplesect>

      <simplesect>
        <title>Marking the DAO interfaces to be Spring beans</title>

        <para>The DAO interfaces Hades creates beans for are marked with the
        usual Spring Bean S you are used to from other bean classes.</para>
      </simplesect>

      <simplesect>
        <title>Content assist for bean references is aware of Hades
        beans</title>

        <para>Trying to reference a DAO bean will now correctly show up the
        beans as suggestions during content assist.</para>

        <figure id="hades-xml-editor">
          <title>Hades integration into Spring IDE</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/hades-xml-editor.png" width="100%" />
            </imageobject>
          </mediaobject>
        </figure>
      </simplesect>
    </section>
  </chapter>

  <appendix>
    <title>Namespace reference</title>

    <section>
      <title>The <code>&lt;dao-config /&gt;</code> element</title>

      <para>The <code>&lt;dao-config /&gt;</code> element acts as container
      for <code>&lt;dao /&gt;</code> elements or can be left empty to trigger
      auto detection<footnote>
          <para>see <xref linkend="config.autoconfig" /></para>
        </footnote> of DAO instances. Attributes defined for
      <code>&lt;dao-config /&gt;</code> act are propagated to contained
      <code>&lt;dao /&gt;</code> elements but can be overridden of
      course.</para>

      <table>
        <title>Attributes</title>

        <tgroup cols="2">
          <colspec colwidth="1*" />

          <colspec colwidth="2*" />

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>base-package</code></entry>

              <entry>Defines the package to be used to construct DAO inteface
              names from or to be scanned for DAO interfaces extending
              <interfacename>GenericDao</interfacename> in auto detection
              mode. All packages below the configured package will be scanned,
              too. In auto configuration mode (no nested <code>&lt;dao
              /&gt;</code> elements) wildcards are also allowed.</entry>
            </row>

            <row>
              <entry><code>dao-impl-postfix</code></entry>

              <entry>Defines the postfix to autodetect custom DAO
              implementations. Classes whose names end with the configured
              postfix will be considered as candidates. Defaults to
              <code>Impl</code>.</entry>
            </row>

            <row>
              <entry><code>query-lookup-strategy</code></entry>

              <entry>Determines the strategy to be used to create finder
              queries. See <xref linkend="sample-app.finders.strategies" />
              for details. Defaults to
              <code>create-if-not-found</code>.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>The <code>&lt;dao /&gt;</code> element</title>

      <para>The <code>&lt;dao /&gt;</code> element can contain all attributes
      of <code>&lt;dao-config /&gt;</code> except <code>base-package</code>.
      This will result in overriding the values configured in the surrounding
      <code>&lt;dao-config /&gt;</code> block. Thus here we will only document
      extended attributes.</para>

      <table>
        <title>Attributes</title>

        <tgroup cols="2">
          <colspec colwidth="1*" />

          <colspec colwidth="2*" />

          <tbody>
            <row>
              <entry><code>id</code></entry>

              <entry>Defines the id of the bean the DAO instance will be
              registered under as well as the DAO interface name.</entry>
            </row>

            <row>
              <entry><code>custom-impl-ref</code></entry>

              <entry>Defines a reference to a custom DAO implementation
              bean.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </appendix>

  <appendix>
    <title>Frequently asked questions</title>

    <qandaset>
      <qandadiv>
        <title>Infrastructure</title>

        <qandaentry>
          <question>
            <para>Currently I have implemented a DAO layer based on
            <classname>HibernateDaoSupport</classname>. I create a
            <classname>SessionFactory</classname> by using Springs
            <classname>AnnotationSessionFactoryBean</classname>. How do I get
            Hades DAOs working in this environment.</para>
          </question>

          <answer>
            <para>You have to replace
            <classname>AnnotationSessionFactoryBean</classname> with the
            <classname>LocalContainerEntityManagerFactoryBean</classname> as
            described in <xref
            linkend="infrastructure.entity-manager-factory" />. Supposed you
            have registered it under <code>entityManagerFactory</code> you can
            reference it in you DAOs based on
            <classname>HibernateDaoSupport</classname> as follows:</para>

            <example>
              <title>Looking up a SessionFactory from an
              HibernateEntityManagerFactory</title>

              <programlisting language="xml">&lt;bean class="com.acme.YourDaoBasedOnHibernateDaoSupport"&gt;
  &lt;property name="sessionFactory"&gt;
    &lt;bean factory-bean="entityManagerFactory" 
      factory-method="getSessionFactory" /&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>
            </example>
          </answer>
        </qandaentry>
      </qandadiv>

      <qandadiv>
        <title>Auditing</title>

        <qandaentry>
          <question>
            <para>I want to use Hades auditing capabilities but have my
            database already set up to set modification and creation date on
            entities. How to preven Hades to set the date
            programmatically.</para>
          </question>

          <answer>
            <para>Just configure <classname>AuditingAdvice</classname>
            accordingly. The property you might want to look for is
            <code>dateTimeForNow</code>.</para>
          </answer>
        </qandaentry>
      </qandadiv>
    </qandaset>
  </appendix>

  <glossary>
    <glossdiv>
      <title>A</title>

      <glossentry>
        <glossterm>AOP</glossterm>

        <glossdef>
          <para>Aspect oriented programming</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>C</title>

      <glossentry>
        <glossterm>Commons DBCP</glossterm>

        <glossdef>
          <para>Commons DataBase Connection Pools - Library of the Apache
          foundation offering pooling implementations of the
          <interfacename>DataSource</interfacename> interface.</para>
        </glossdef>
      </glossentry>

      <glossentry>
        <glossterm>CRUD</glossterm>

        <glossdef>
          <para>Create, Read, Update, Delete - Basic persistence
          operations</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>D</title>

      <glossentry>
        <glossterm>DAO</glossterm>

        <glossdef>
          <para>Data Access Object - Pattern to separate persisting logic from
          the object to be persisted</para>
        </glossdef>
      </glossentry>

      <glossentry>
        <glossterm>Dependency Injection</glossterm>

        <glossdef>
          <para>Pattern to hand a component's dependency to the component from
          outside, freeing the component to lookup the dependant itself. For
          more information see <ulink
          url="http://en.wikipedia.org/wiki/Dependency_Injection">http://en.wikipedia.org/wiki/Dependency_Injection</ulink>.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>E</title>

      <glossentry>
        <glossterm>EclipseLink</glossterm>

        <glossdef>
          <para>Object relational mapper implementing JPA - <ulink
          url="http://www.eclipselink.org">http://www.eclipselink.org</ulink></para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>H</title>

      <glossentry>
        <glossterm>Hibernate</glossterm>

        <glossdef>
          <para>Object relational mapper implementing JPA - <ulink
          url="http://www.hibernate.org">http://www.hibernate.org</ulink></para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>J</title>

      <glossentry>
        <glossterm>JPA</glossterm>

        <glossdef>
          <para>Java Persistence Api</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>S</title>

      <glossentry>
        <glossterm>Spring</glossterm>

        <glossdef>
          <para>Java application framework - <ulink
          url="http://www.springframework.org">http://www.springframework.org</ulink></para>
        </glossdef>
      </glossentry>
    </glossdiv>
  </glossary>
</book>