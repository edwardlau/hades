<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
	"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<book>
  <bookinfo>
    <title>Hades</title>

    <subtitle>Domain class and DAO development framework</subtitle>

    <authorgroup>
      <author>
        <firstname>Oliver</firstname>

        <surname>Gierke</surname>

        <affiliation>
          <jobtitle>Senior Consultant</jobtitle>

          <orgname>SpringSource - a division of VMware</orgname>
        </affiliation>

        <email>ogierke@vmware.com</email>
      </author>
    </authorgroup>

    <releaseinfo>&version;</releaseinfo>

    <pubdate>&date;</pubdate>

    <copyright>
      <year>2008-2010</year>

      <holder>The original authors</holder>
    </copyright>

    <revhistory>
      <revision>
        <date>29.04.2008</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Initial draft</revremark>
      </revision>

      <revision>
        <date>13.05.2008</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>RC1</revremark>
      </revision>

      <revision>
        <date>13.05.2008</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>RC2 - Added auto configuration, annotation configuration
        for namespaces and finder methods for single instances</revremark>
      </revision>

      <revision>
        <date>28.10.2008</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Polished code samples a little, added appendix for
        namespace configuration</revremark>
      </revision>

      <revision>
        <date>29.11.2008</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Added documentation for EclipseLink, fixed various typos,
        XML namespace corrections</revremark>
      </revision>

      <revision>
        <date>06.12.2008</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Prepare 0.3</revremark>
      </revision>

      <revision>
        <date>26.01.2009</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Updated version and copyright date</revremark>
      </revision>

      <revision>
        <date>06.02.2009</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Added FAQ entry how to integrate Hades into existing DAO
        layer based on HibernateDaoSupport</revremark>
      </revision>

      <revision>
        <date>19.02.2009</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Added chapter on Hades Eclipse plugin, removed remarks on
        configuration of dao base class, some typos</revremark>
      </revision>

      <revision>
        <date>02.04.2009</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Preare version 0.5</revremark>
      </revision>

      <revision>
        <date>28.08.2009</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Cleaned up "finder" against "query" - relates to
        #104</revremark>
      </revision>

      <revision>
        <date>29.08.2009</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Added documentation of execution of manipulating
        queries</revremark>
      </revision>

      <revision>
        <date>17.10.2009</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Added documentation of how to use named
        parameters</revremark>
      </revision>

      <revision>
        <date>23.10.2009</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Final polishes for 1.0 release</revremark>
      </revision>

      <revision>
        <date>16.12.2009</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Added documentation of how to add custom behaviour to all
        DAOs</revremark>
      </revision>

      <revision>
        <date>19.03.2010</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Added documentation of usage of multiple
        EntityManagerFactories</revremark>
      </revision>

      <revision>
        <date>10.04.2010</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Removed references to Persistable in examples where not
        needed, mentioned @NoDaoBean, fixed some typos here and there,
        metadata cleanup</revremark>
      </revision>

      <revision>
        <date>29.05.2010</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Added documentation on transactional behaviour</revremark>
      </revision>

      <revision>
        <date>30.05.2010</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Added documentation of include-filter and exclude-filter
        elements</revremark>
      </revision>

      <revision>
        <date>12.07.2010</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Added documentation of new keywords in query creation,
        updated auditing, added chapters on project metadata</revremark>
      </revision>

      <revision>
        <date>31.07.2010</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Added FAQ on more detailled logging (see #329)</revremark>
      </revision>

      <revision>
        <date>05.08.2010</date>

        <author>
          <firstname>Oliver</firstname>

          <surname>Gierke</surname>
        </author>

        <revremark>Added documentation of Specifications feature</revremark>
      </revision>
    </revhistory>
  </bookinfo>

  <preface>
    <title>Preface</title>

    <section>
      <title>Assumptions</title>

      <para>As Hades makes heavy use of Spring and JPA we assume you have
      certain knowledge of how to work with theses frameworks and
      specifications. Hades is implemented using some container hooks of
      Spring, AOP features. Nevetheless you do not have to have deep insight
      in conainer internals to use Hades although it would let you understand
      things more deeply.</para>
    </section>

    <section>
      <title>Technologies</title>

      <simplesect>
        <title>JPA</title>

        <para>The Java Persistence API was invented in conjunction with EJB3
        and serves as standard for persisting objects in JavaSE and JavaEE
        environments. It abstracts differences of various available OR Mappers
        like Hibernate and EclipseLink and guarantees interoperability as far
        as possible. Although the version 1.0 has its shortcomings, JPA can be
        considered a future technology.</para>
      </simplesect>

      <simplesect>
        <title>Spring</title>

        <para>Spring is the defacto standard application framework for Java
        applications. Its consistent programming model, easy configuration and
        wide support for all kinds of third party libraries makes it the first
        class citizen of application frameworks.</para>
      </simplesect>

      <simplesect>
        <title>Spring &amp; JPA</title>

        <para>Spring offers a lot of support for various technologies in data
        access area. It's main benefit regarding JPA is the ease and power of
        configuration along with proper exception translation into Spring's
        <classname>DataAccessException</classname> hierarchy.</para>
      </simplesect>
    </section>

    <section>
      <title>Project metadata</title>

      <itemizedlist spacing="compact">
        <listitem>
          <para>Version control - <ulink
          url="http://svn.synyx.org/synyx/opensource/hades">http://svn.synyx.org/synyx/opensource/hades</ulink></para>
        </listitem>

        <listitem>
          <para>Bugtracker - <ulink
          url="http://hades.synyx.org">http://hades.synyx.org</ulink></para>
        </listitem>

        <listitem>
          <para>Repository - <ulink
          url="http://repo2.maven.org/maven2/org/synyx/hades">http://repo2.maven.org/maven2/org/synyx/hades</ulink></para>
        </listitem>

        <listitem>
          <para>Snapshot repsitory - <ulink
          url="https://oss.sonatype.org/content/repositories/snapshots/org/synyx/hades">https://oss.sonatype.org/content/repositories/snapshots/org/synyx/hades</ulink></para>
        </listitem>
      </itemizedlist>
    </section>
  </preface>

  <chapter>
    <title>Core concepts</title>

    <section>
      <title>Introduction</title>

      <para>Implementing a data access layer of an application has been
      cumbersome for quite a while. To much boilerplate code had to be
      written. Domain classes were anemic and havent been designed in a real
      object oriented or domain driven manner.</para>

      <para>The last few years have brought a lot of evolution regarding those
      topics. JPA brought annotation driven persistence into Java, Spring
      established as lightweight Java development framework offering a lot of
      support especially in the area of data access.</para>

      <para>Using both of these technologies makes developers life a lot
      easier regarding rich domain model's persistence. Nevertheless the
      amount of boilerplate code especially for <glossterm>DAO</glossterm>s is
      still quite high. Besides that there is no higher level concept
      supporting you designing persistent domain classes. Hades is aiming to
      bridge that gap, providing sophisticated support for domain modeling and
      easing persistence.</para>

      <para>The following chapters will introduce the core concepts and
      interfaces of Hades roughly surrounding various steps of sophistication.
      All these step will bring significant benefit to your application but
      will introduce certain restrictions. So it's up to you to choose.</para>
    </section>

    <section>
      <title>Entities and DAOs</title>

      <para>The central interface in Hades is
      <interfacename>GenericDao</interfacename>. It is typed with the entity
      class to manage as well as the id type of the entity and provides some
      sophisticated functionality around CRUD for the entity managed.</para>

      <example id="example.generic-dao">
        <title>GenericDao Interface</title>

        <programlistingco>
          <areaspec>
            <area coords="4" id="generic-dao.save" />

            <area coords="6" id="generic-dao.save-and-flush" />

            <area coords="8" id="generic-dao.read-by-primary-key" />

            <area coords="10" id="generic-dao.read-all" />

            <area coords="12" id="generic-dao.read-all-pageable" />

            <area coords="14" id="generic-dao.count" />

            <area coords="16" id="generic-dao.delete" />

            <area coords="18" id="generic-dao.flush" />

            <area coords="20" id="generic-dao.exists" />
          </areaspec>

          <programlisting language="java">public interface GenericDao&lt;T, PK extends Serializable&gt; {

    T save(T entity);

    T saveAndFlush(T entity);

    T readByPrimaryKey(PK primaryKey);

    List&lt;T&gt; readAll();

    Page&lt;T&gt; readAll(Pageable pageable);

    Long count();

    void delete(T entity);

    void flush();

    boolean exists(PK primaryKey);

    // … more functionality omitted.
}</programlisting>

          <calloutlist>
            <callout arearefs="generic-dao.save">
              <para>Saves the given entity.</para>
            </callout>

            <callout arearefs="generic-dao.save-and-flush">
              <para>Saves the given entity and immediately flushes changes to
              the database.</para>
            </callout>

            <callout arch="" arearefs="generic-dao.read-by-primary-key">
              <para>Returns the entity identified by the given id.</para>
            </callout>

            <callout arearefs="generic-dao.read-all">
              <para>Returns all entities.</para>
            </callout>

            <callout arch="" arearefs="generic-dao.read-all-pageable">
              <para>Returns a page of entities.</para>
            </callout>

            <callout arearefs="generic-dao.count">
              <para>Returns the number of entities.</para>
            </callout>

            <callout arearefs="generic-dao.delete">
              <para>Deletes the given entity.</para>
            </callout>

            <callout arearefs="generic-dao.flush">
              <para>Flushes pending changes to the database.</para>
            </callout>

            <callout arearefs="generic-dao.exists">
              <para>Returns whether an entity with the given id exists.</para>
            </callout>
          </calloutlist>
        </programlistingco>
      </example>

      <para>Hades provides a <classname>GenericDaoFactoryBean</classname> that
      allows setting up instances for this interface in declarative manner. So
      all you need to do is declaring an interface extending and thus typing
      the generic interface accordingly. To create DAO instances
      programatically Hades provides <classname>GenericDaoFactory</classname>.
      Read more on configuration in <xref
      linkend="sample-app.configuration" />.</para>
    </section>

    <section>
      <title>Auditablity</title>

      <para>Most applications will require some auditability for entities
      allowing to track creation date and user and modification date and user.
      Hades provides facilities to add this audition information to entity
      transparently by AOP means. To take part in this functionality your
      domain classes have to implement a more advanced interface:</para>

      <example>
        <title><interfacename>Auditable</interfacename> interface</title>

        <programlisting language="java">public interface Auditable&lt;U extends Persistable&lt;PK&gt;, PK extends Serializable&gt;
        extends Persistable&lt;PK&gt; {

    U getCreatedBy();

    void setCreatedBy(U createdBy);

    DateTime getCreatedDate();

    void setCreated(Date creationDate);

    U getLastModifiedBy();

    void setLastModifiedBy(U lastModifiedBy);

    DateTime getLastModifiedDate();

    void setLastModified(Date lastModifiedDate);
}</programlisting>
      </example>

      <para>As you can see the modifying entity itself only has to be an
      entity. Mostly this will be some sort of User entity, so we chose U as
      parameter type.</para>

      <note>
        <para>To minimize boilerplate code Hades offers
        <classname>AbstractPersistable</classname> and
        <classname>AbstractAuditable</classname> base classes that implement
        and preconfigure entities. Thus you can decide to only implement the
        interface or enjoy more sophisticated support by extending the base
        class.</para>
      </note>

      <simplesect>
        <title><code>General auditing configuration</code></title>

        <para>Hades ships with an entity listener that can be used to trigger
        capturing auditing information. So first you have to register the
        <classname>AuditingEntityListener</classname> inside your
        <filename>orm.xml</filename> to be used for all entities in your
        persistence contexts:</para>

        <example>
          <title>Auditing configuration orm.xml</title>

          <programlisting language="xml">&lt;persistence-unit-metadata&gt;
  &lt;persistence-unit-defaults&gt;
    &lt;entity-listeners&gt;
      &lt;entity-listener class="….hades.domain.auditing.support.AuditingEntityListener" /&gt;
    &lt;/entity-listeners&gt;
  &lt;/persistence-unit-defaults&gt;
&lt;/persistence-unit-metadata&gt;</programlisting>
        </example>

        <para>Now activating auditing functionlity is just a matter of adding
        the Hades auditing namespace element to your configuration:</para>

        <example>
          <title>Activating auditing in the Spring configuration</title>

          <programlisting language="xml">&lt;hades:auditing auditor-aware-ref="yourAuditorAwareBean" /&gt;</programlisting>
        </example>

        <para>As you can see you have to provide a bean that implements the
        <interfacename>AuditorAware</interfacename> interface which looks as
        follows:</para>

        <example>
          <title><interfacename>AuditorAware</interfacename> interface</title>

          <programlisting language="java">public interface AuditorAware&lt;T, PK extends Serializable&gt; {

    T getCurrentAuditor();
}</programlisting>
        </example>

        <para>Usually you will have some kind of authentication component in
        your application that tracks the user currently working with the
        system. This component should be
        <interfacename>AuditorAware</interfacename> and thus allow seemless
        tracking of the auditor.</para>
      </simplesect>
    </section>
  </chapter>

  <chapter>
    <title>Sample application</title>

    <section>
      <title>Introduction</title>

      <para>In order to introduce you to working with Hades we will develop a
      small sample application managing users. As Hades is focussing on
      development of domain classes and persistence it will not be a full
      fledged application but rather concentrate on that particular part of an
      application built around the demo app.</para>

      <para>We will start by assuming that only want to have basic Hades
      support stepping forward using more sophisticated features of it.</para>

      <section>
        <title>Configuration</title>

        <para>To get started with Hades you need to setup your application in
        the standard Spring manner. The following examples leverage XML
        configuration style of the container but you could easily use other
        approaches as well. We will separate configuration into two files.
        <filename>infrastructure.xml</filename> contains a the basic
        infrastructure setup descibed in the next chapter. This one will be
        used over the various sophistication levels of Hades. Beyond that we
        will create certain further config files that contain configuration
        for various sophistication levels.</para>
      </section>
    </section>

    <section id="infrastructure">
      <title>Infrastructure</title>

      <simplesect>
        <title><interfacename>DataSource</interfacename></title>

        <para>As you might already know, Spring's data base access support is
        mainly centered around working with a
        <interfacename>DataSource</interfacename> implementation. Although you
        should rely on more sophisticated
        <interfacename>DataSource</interfacename> implementations like Commons
        DBCP, Spring comes with <classname>DriverManagerDataSource</classname>
        out of the box that should be satisfying for testing purposes.</para>

        <note>
          <para>Environment specific configuration that highly varies between
          deployments should not be hardcoded into a Spring configuration
          file. Preferably, use a
          <classname>PropertyPlaceholderConfigurer</classname><footnote>
              <para>For more information see <ulink
              url="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-factory-placeholderconfigurer">Spring's
              reference documentation</ulink> on that topic</para>
            </footnote> to externalize those kinds of settings into an
          external properties file that can easily customized by application
          administrators.</para>
        </note>

        <para>So we setup an instance of it in typical Spring Dependency
        Injection manner.</para>

        <example>
          <title>DataSource configuration</title>

          <programlistingco>
            <areaspec>
              <area coords="3" id="data-source.driver-class-name" />

              <area coords="4" id="data-source.url" />

              <area coords="5" id="data-source.username" />

              <area coords="6" id="data-source.password" />
            </areaspec>

            <programlisting language="xml">&lt;bean id="dataSource" 
  class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
  &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt;
  &lt;property name="url" value="jdbc:mysql://localhost:3306/hades" /&gt;
  &lt;property name="username" value="username" /&gt;
  &lt;property name="password" value="password" /&gt;
&lt;/bean&gt;</programlisting>

            <calloutlist>
              <callout arearefs="data-source.driver-class-name">
                <para>Configure your database vendor's specific driver
                class</para>
              </callout>

              <callout arearefs="data-source.url">
                <para>Point the data source to your database's location</para>
              </callout>

              <callout arearefs="data-source.username data-source.password">
                <para>Authentication credentials</para>
              </callout>
            </calloutlist>
          </programlistingco>
        </example>
      </simplesect>

      <simplesect id="infrastructure.entity-manager-factory">
        <title><interfacename>EntityManager</interfacename>(<interfacename>Factory</interfacename>)</title>

        <example>
          <title><interfacename>EntityManager</interfacename>
          configuration</title>

          <programlistingco>
            <areaspec>
              <area coords="3" id="entity-manager-factory.data-source" />

              <area coords="4" id="entity-manager-factory.jpa-vendor-adapter" />
            </areaspec>

            <programlisting language="xml">&lt;bean id="entityManagerFactory"
  class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="dataSource" ref="dataSource" /&gt;
  &lt;property name="jpaVendorAdapter"&gt;
    &lt;bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"&gt;
      &lt;property name="showSql" value="true" /&gt;
      &lt;property name="generateDdl" value="true" /&gt;
      &lt;property name="database" value="MYSQL" /&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

            <calloutlist>
              <callout arearefs="entity-manager-factory.data-source">
                <para>Reference the DataSource declared before</para>
              </callout>

              <callout arearefs="entity-manager-factory.jpa-vendor-adapter">
                <para>Apply a vendor specific adapter to add further
                configuration. In this case we use Hibernate and tell it to
                use MySQL dialect for accessing the database, generate the
                required database tables as needed and log SQL queries fired
                to the database</para>
              </callout>
            </calloutlist>
          </programlistingco>
        </example>

        <para>As you can see we have configured an
        <classname>EntityManagerFactoryBean</classname> to work with Hibernate
        in our case. As Hades supports any JPA provider, we do not declare
        mandatory dependencies in our <filename>pom.xml</filename>. Thus,
        you'll have to add the persistence provider of your choice to your
        project. In our case this would look something like this:</para>

        <example>
          <title>Hibernate dependency</title>

          <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
  &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;
  &lt;version&gt;3.5.3-Final&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
        </example>

        <note>
          <para>You might have to add other dependencies as well (SLF4J in
          case of Hibernate). So check the documentation of your persistence
          provider for setup details.</para>
        </note>
      </simplesect>

      <simplesect>
        <title>Transaction management</title>

        <para>Spring leverages consistent transaction abstraction through its
        <interfacename>PlatformTransactionManager</interfacename> interface
        and provides a <classname>JpaTransactionManager</classname>
        implementation out of the box.</para>

        <example>
          <title>Transaction manager configuration</title>

          <programlisting language="xml">&lt;bean id="transactionManager"
  class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
  &lt;property name="entityManagerFactory" ref="entityManagerFactory" /&gt;
&lt;/bean&gt;</programlisting>
        </example>
      </simplesect>

      <simplesect>
        <title>BeanPostProcessors</title>

        <para>As Hades leverages Spring 2.5 annotations to activate exception
        translation and injecting <interfacename>EntityManager</interfacename>
        instances we need to configure 2
        <interfacename>BeanPostProcessor</interfacename>s.</para>

        <example>
          <title>BeanPostProcessor configuration</title>

          <programlisting language="xml">&lt;bean
  class="org...PersistenceAnnotationBeanPostProcessor" /&gt;

&lt;bean
  class="org...PersistenceExceptionTranslationPostProcessor" /&gt;</programlisting>
        </example>
      </simplesect>
    </section>

    <section>
      <title>Basic entities and DAOs</title>

      <para>Now we are going to create the entities and DAOs needed to manage
      users with roles. Note that we will start with an implementation with
      the least possible coupling to Hades. The will force us to configure a
      few things ourselves but decrease dependencies. If you want to know, how
      you can ease things a little more see <xref
      linkend="sample-app.base-classes" /> and <xref
      linkend="sample-app.namespace" />.</para>

      <section>
        <title>Users and roles</title>

        <para>As we want to create a small user management application, the
        primary entities we will deal with are <classname>User</classname> and
        <classname>Role</classname>. Take a look at the code snippets:</para>

        <example>
          <title><classname>User</classname> entity</title>

          <programlisting language="java">@Entity
public class User {

  public static final long serialVersionUID = 123L

  @Id
  @GeneratedValue(strategy = GenerationType.AUTO)
  private Long id;
  private String username;
  private String password;
  private String emailAddress;

  @ManyToMany
  private Set&lt;Role&gt; roles;

  public Long getId() {
    return this.id;
  }

  // Further getters and setters omitted

  public boolean isNew() {
    return null == this.id;
  }
}</programlisting>
        </example>

        <para>Note that we decide to have an id type of
        <classname>Long</classname>. We have to add annotations for the id
        ourselves and implement <methodname>isNew()</methodname> manually,
        too. We create a many-to-many relationship to the <code>Role</code>
        class and store some string values like username, password and email
        address.</para>

        <example>
          <title><classname>Role</classname> entity</title>

          <programlisting language="java">@Entity
public class Role {

  private static final long serialVersionUID = -123L;

  @Id
  @GeneratedValue(strategy = GenerationType.AUTO)
  private Integer id;
  private String name;

  public Integer getId() {
    return this.id;
  }

  // Further getters and setters omitted

  public boolean isNew() {
    return null == this.id;
  }
}</programlisting>
        </example>

        <para>The <classname>Role</classname> class looks quite similar. Note
        that we decide for an alternate id type. So mixing id type is no
        problem at all.</para>
      </section>

      <section>
        <title>DAOs</title>

        <para>As we have modeled the entities we need to add an interface for
        a DAO handling persistence operations for them:</para>

        <example>
          <title>UserDao and RoleDao interface</title>

          <programlisting language="java">public interface UserDao extends GenericDao&lt;User, Long&gt; {
}</programlisting>

          <programlisting language="java">public interface RoleDao extends GenericDao&lt;Role, Integer&gt; {
}</programlisting>

          <para>As you can see the interfaces serve typing purposes only for
          now. We will add further functionality to them later.
          <interfacename>GenericDao</interfacename> provides most of the
          required persistence operations. Hades provides various
          implementations of this interface so that you don't need to code one
          on your own.</para>
        </example>
      </section>

      <section id="sample-app.configuration">
        <title>Configuration</title>

        <para><classname>GenericJpaDao</classname> is the base implementation
        of <interfacename>GenericDao</interfacename> that serves basic
        purposes very well. It uses Spring's exception translation and entity
        manager injection facilities so that its creation logic is
        encapsulated into <classname>GenericDaoFactoryBean</classname>. So the
        basic configuration for a DAO instance looks as follows:</para>

        <example>
          <title>Simple DAO configuration</title>

          <programlistingco>
            <areaspec>
              <area coords="1" id="simple-dao-config.infrastructure-import" />

              <area coords="6" id="simple-dao-config.dao-interface" />
            </areaspec>

            <programlisting language="xml">&lt;import resource="infrastructure.xml" /&gt;

&lt;bean id="userDao" 
    class="org.synyx.hades.dao.orm.GenericDaoFactoryBean"&gt;
  &lt;property name="daoInterface" value="org.synyx.hades.dao.UserDao" /&gt;
&lt;/bean&gt;

&lt;bean id="roleDao"
    class="org.synyx.hades.dao.orm.GenericDaoFactoryBean"&gt;
  &lt;property name="daoInterface" value="org.synyx.hades.dao.RoleDao" /&gt;
&lt;/bean&gt;</programlisting>

            <calloutlist>
              <callout arearefs="simple-dao-config.infrastructure-import">
                <para>Import infrastructure configuration. Supposed we have
                combined the configuration examples shown in <xref
                linkend="infrastructure" /> into a file named
                <filename>infrastructure.xml</filename></para>
              </callout>

              <callout arearefs="simple-dao-config.dao-interface">
                <para>Declare the DAO interface you want to expose. This
                interface has to extend
                <interfacename>GenericDao</interfacename>.</para>
              </callout>
            </calloutlist>
          </programlistingco>
        </example>

        <para>This is smallest standard XML configuration possible. There are
        a lot more options on <classname>GenericDaoFactoryBean</classname>,
        but you rather choose XML namespace configuration due to less
        verbosity.</para>
      </section>

      <section>
        <title>Client code</title>

        <para>The previously declared <interfacename>UserDao</interfacename>
        can be accessed via its bean id from the
        <interfacename>ApplicationContext</interfacename>, although you
        definately are better off letting the container inject it into you
        client:</para>

        <example>
          <title>Manual lookup of UserDao</title>

          <programlisting language="java">ApplicationContext ctx = new ClasspathXmlApplicationContext(
  "applicationContext.xml");
UserDao userDao = (UserDao) ctx.getBean("userDao");

User user = userDao.readByPrimaryKey(1L);</programlisting>
        </example>
      </section>
    </section>

    <section id="sample-app.namespace">
      <title>Easing configuration - Spring namespaces</title>

      <para>Configuring DAOs the standard way can become cumbersome if your
      application requires a lot of DAOs. With help of Spring 2.5 namespaces
      there is a more sophisticated way to configure them.</para>

      <example>
        <title>DAO configuration with Spring namespaces</title>

        <programlistingco>
          <areaspec>
            <area coords="4" id="config.dao-ns-import" />

            <area coords="7" id="config.dao-ns-location" />

            <area coords="10" id="config.import-infrastructure" />

            <area coords="12" id="config.dao-config" />

            <area coords="13" id="config.dao-instance" />
          </areaspec>

          <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:hades="http://schemas.synyx.org/hades"
  xsi:schemaLocation="http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
    http://schemas.synyx.org/hades
    http://schemas.synyx.org/hades/hades.xsd"&gt;

  &lt;import resource="infrastructure.xml" /&gt;

  &lt;hades:dao-config base-package="org.synyx.hades.dao"&gt;
    &lt;hades:dao id="userDao" /&gt;
    &lt;hades:dao id="roleDao" /&gt;
  &lt;/hades:dao-config&gt;

&lt;/beans&gt;</programlisting>

          <calloutlist>
            <callout arearefs="config.dao-ns-import config.dao-ns-location">
              <para>Import the dao namespace to be available in the xml
              configuraton document.</para>
            </callout>

            <callout arearefs="config.import-infrastructure">
              <para>Import infrastructure configuration.</para>
            </callout>

            <callout arearefs="config.dao-config">
              <para>Declare base packages to construct domain classes and DAO
              interfaces.</para>
            </callout>

            <callout arearefs="config.dao-instance">
              <para>Declare a single DAO instance. Each <code
              language="xml">&lt;dao /&gt;</code> element will result in a
              single declaration of a
              <classname>GenericDaoFactoryBean</classname> with a DAO
              interface set to
              <code>${dao-config.base-package}.${dao.id}</code>. Given this
              example this will result in a DAO interface of
              <interfacename>org.synyx.hades.dao.UserDao</interfacename>
              registered under <code>userDao</code>.</para>
            </callout>
          </calloutlist>
        </programlistingco>
      </example>

      <para>This configuration replaces simple configuration mechanism
      entirely so we encourage to use this kind of configuration over the
      simple one.</para>

      <para>The <code>&lt;dao-config /&gt;</code> element allows two further
      attributes to be defined. With <code>dao-name-postfix</code> you can
      customize the bean id for the DAO registered. This defaults to
      <code>Dao</code>.</para>

      <section id="config.autoconfig">
        <title>Auto configuration</title>

        <para>You can simplify configuration even more by adding no
        <code>&lt;dao /&gt;</code> elements to <code>&lt;dao-config
        /&gt;</code> at all.</para>

        <example>
          <title>Automatic DAO configuration</title>

          <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:hades="http://schemas.synyx.org/hades"
  xsi:schemaLocation="http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://schemas.synyx.org/hades 
    http://schemas.synyx.org/hades/hades.xsd"&gt;

  &lt;import resource="infrastructure.xml" /&gt;

  &lt;hades:dao-config base-package="org.synyx.hades.dao" /&gt;

&lt;/beans&gt;</programlisting>
        </example>

        <para>This will trigger auto detection mechanism of DAOs that extend
        <interfacename>GenericDao</interfacename> or
        <interfacename>ExtendedGenericDao</interfacename>. For each candidate
        found it will set up an DAO instances supposing you've placed the DAO
        interfaces in the configured package and named them as described
        above.<note>
            <para>In case you need to wire an
            <interfacename>EntityManagerFactory</interfacename> to a DAO
            instance or all DAO instances explicitly use
            <code>entity-manager-factory-ref</code> attribute to point to the
            desired Spring bean.</para>
          </note></para>
      </section>

      <section>
        <title>Using filters</title>

        <para>By default Hades will pick up every interface extending
        <interfacename>GenericDao</interfacename> located underneath the
        configured base package and create a bean instance for it. However,
        you might want to gain finer grained control over which interfaces
        bean instances get created for. Hades supports the use of
        <code>&lt;include-filter /&gt;</code> and <code>&lt;exclude-filter
        /&gt;</code> elements inside <code>&lt;dao-config /&gt;</code>. The
        samantics are exactly equivalent to the elements in Spring's context
        namespace. For details see <ulink
        url="http://static.springsource.org/spring/docs/2.5.x/reference/beans.html#beans-scanning-filters"
        vendor="">Spring reference documentation</ulink> on these
        elements.</para>

        <para>E.g. to exclude certain interfaces from instantiation as Hades
        DAO, you could use the following configuration:</para>

        <example>
          <title>Using exclude-filter element</title>

          <programlisting language="xml">&lt;hades:dao-config base-package="org.synyx.hades.dao"&gt;
  &lt;exclude-filter type="regex" expression=".*SomeDao" /&gt;
&lt;/hades:dao-config&gt;
</programlisting>

          <para>This would exclude all interface ending on
          <interfacename>SomeDao</interfacename> from being
          instantiated.</para>
        </example>
      </section>
    </section>

    <section id="finder-methods">
      <title>Query methods</title>

      <para>Next to standard CRUD functionality
      <classname>GenericJpaDao</classname> allows sophisticated execution of
      queries by declaring methods in the DAO interface. Let's see how
      configuration of a query to lookup users by their email address can be
      realized.</para>

      <section id="sample-app.finders.strategies">
        <title>Query lookup strategies</title>

        <para>Queries can be executed with 3 different strategies. These
        strategies define how the JPA query is constructed at runtime. These
        strategies can either be configured at the
        <interfacename>GenericDaoFactoryBean</interfacename> directly or used
        via XML namespace configuration.</para>

        <simplesect>
          <title>CREATE</title>

          <para>This strategy will try to construct a JPA query from the query
          method's name. Thus you don't need to declare a named query
          explicitly. This is quite useful if the queries are simple and no
          special JPA QL is required. <code>CREATE</code> strategy ties your
          mehod names to the query, what might be unwanted. Read more about
          query construction in <xref
          linkend="finder-methods.query-creation" />.</para>
        </simplesect>

        <simplesect>
          <title>USE_DECLARED_QUERY</title>

          <para>This strategy tries to find a declared query that can either
          be defined using JPA <code>@NamedQuery</code> means or Hades
          <code>@Query</code> annotation (see <xref
          linkend="finder-methods.named-queries" /> and <xref
          linkend="finder-methods.at-query" /> for details). If no declared
          query is found execution of the query will fail.</para>
        </simplesect>

        <simplesect>
          <title>CREATE_IF_NOT_FOUND (default)</title>

          <para>This strategy is actually a combination of the both mentioned
          above. It will try to lookup a declared query first but create a
          custom method name based query if no named query was found. This is
          default lookup strategy and thus will be used if you don't configure
          anything explicitly. It allows quick query definition by method
          names but also custom tuning of these queries by introducing
          declared queries for those who need explicit tuning.</para>
        </simplesect>
      </section>

      <section id="finder-methods.query-creation">
        <title>Query creation</title>

        <para>The hades query builder mechanism is useful to build basic
        <code>WHERE</code> clauses queries. Hades will directly translate the
        method name into a where clause. Basically you can define conditions
        on direct entity properties and concatenate them with <code>AND</code>
        and <code>OR</code>.<example>
            <title>Query creation from method names</title>

            <para><programlisting language="java">public interface UserDao extends GenericDao&lt;User, Long&gt; {

  findByEmailAddressAndLastname(String emailAddress, String lastname);
}</programlisting>This method will result in the following query:</para>

            <programlisting>from User u where u.emailAddress = ?1 and u.lastname = ?2</programlisting>

            <para>Hades will check the query against the domain class to
            validate the properties exist. So you either have a property of
            the appropriate name or a getter method. Furthermore Hades will
            strip a list of prefixes from the method name before translating
            it into a query. The prefixes are: <code>findBy</code>,
            <code>find</code>, <code>readBy</code>, <code>read</code>,
            <code>getBy</code> as well as <code>get</code>. Besides
            <code>AND</code> you can use <code>OR</code> to concatenate
            property constraints. Note, that due to the lack of parenthesis
            natural binding order (<code>AND</code> binds more than
            <code>OR</code>) is used for the query.</para>
          </example></para>

        <para><table>
            <title>Supported keywords inside method names</title>

            <tgroup cols="3">
              <colspec colwidth="1*" />

              <colspec colwidth="2*" />

              <colspec colsep="" colwidth="3*" />

              <thead>
                <row>
                  <entry>Keyword</entry>

                  <entry>Sample</entry>

                  <entry>JPQL snippet</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><code>And</code></entry>

                  <entry><code>findByLastnameAndFirstname</code></entry>

                  <entry><code>… where x.lastname = ?1 and x.firstname =
                  ?2</code></entry>
                </row>

                <row>
                  <entry><code>Or</code></entry>

                  <entry><code>findByLastnameOrFirstname</code></entry>

                  <entry><code>… where x.lastname = ?1 or x.firstname =
                  ?2</code></entry>
                </row>

                <row>
                  <entry><code>Between</code></entry>

                  <entry><code>findByStartDateBetween</code></entry>

                  <entry><code>… where x.startDate between 1? and
                  ?2</code></entry>
                </row>

                <row>
                  <entry><code>LessThan</code></entry>

                  <entry><code>findByAgeLessThan</code></entry>

                  <entry><code>… where x.age &lt; ?1</code></entry>
                </row>

                <row>
                  <entry><code>GreaterThan</code></entry>

                  <entry><code>findByAgeGreaterThan</code></entry>

                  <entry><code>… where x.age &gt; ?1</code></entry>
                </row>

                <row>
                  <entry><code>IsNull</code></entry>

                  <entry><code>findByAgeIsNull</code></entry>

                  <entry><code>… where x.age is null</code></entry>
                </row>

                <row>
                  <entry><code>IsNotNull,NotNull</code></entry>

                  <entry><code>findByAge(Is)NotNull</code></entry>

                  <entry><code>… where x.age not null</code></entry>
                </row>

                <row>
                  <entry><code>Like</code></entry>

                  <entry><code>findByFirstnameLike</code></entry>

                  <entry><code>… where x.firstname like ?1</code></entry>
                </row>

                <row>
                  <entry><code>NotLike</code></entry>

                  <entry><code>findByFirstnameNotLike</code></entry>

                  <entry><code>… where x.firstname not like ?1</code></entry>
                </row>

                <row>
                  <entry><code>OrderBy</code></entry>

                  <entry><code>findByAgeOrderByLastnameDesc</code></entry>

                  <entry><code>… where x.age &gt; ?1 order by x.lastname
                  desc</code></entry>
                </row>

                <row>
                  <entry><code>Not</code></entry>

                  <entry><code>findByLastnameNot</code></entry>

                  <entry><code>… where x.lastname &lt;&gt; ?1</code></entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </section>

      <section id="finder-methods.named-queries">
        <title>Using JPA NamedQueries</title>

        <note>
          <para>The examples use simple <code>&lt;named-query /&gt;</code>
          element and <code>@NamedQuery</code> annotation. The queries for
          these configuration elements have to be defined in JPA query
          language. Of course you can use <code>&lt;named-native-query
          /&gt;</code> or <code>@NamedNativeQuery</code>, too. These elements
          allow you to define the query in native SQL by losing the database
          platform independence.</para>
        </note>

        <simplesect>
          <title>XML named query definition</title>

          <para>To use XML configuration simply add the necessary
          <code>&lt;named-query /&gt;</code> element to the
          <filename>orm.xml</filename> JPA configuration file located in
          <filename>META-INF</filename> folder of your classpath. Automatic
          invocation of named queries is enabled by using some defined naming
          convention. For more details see below.</para>

          <example>
            <title>XML named query configuration</title>

            <programlisting language="xml">&lt;named-query name="User.findByLastname"&gt;
  &lt;query&gt;FROM User u WHERE u.lastname = ?1&lt;/query&gt;
&lt;/named-query&gt;</programlisting>
          </example>

          <para>As you can see the query has a special name, the
          <classname>GenericJpaDao</classname> uses to resolve it at
          runtime.</para>
        </simplesect>

        <simplesect>
          <title>Annotation configuration</title>

          <para>Annotation configuration has the advantage not to need another
          config file to be edited, probably lowering maintenance cost. You
          pay for that benefit by the need to recompile your domain class for
          every new query declaration.</para>

          <example>
            <title>Annotation based named query configuration</title>

            <programlisting language="java">@Entity
@NamedQuery(name = "User.findByEmailAddress", 
  query = "FROM User u WHERE u.emailAddress = ?1")
public class User {

}</programlisting>
          </example>
        </simplesect>

        <simplesect>
          <title>Declaring interfaces</title>

          <para>To allow execution of this named query all you need to do is
          to specify the <interfacename>UserDao</interfacename> as
          follows:</para>

          <example>
            <title>Query method declaration in UserDao</title>

            <programlisting language="java">public interface UserDao extends GenericDao&lt;User, Long&gt; {

  List&lt;User&gt; findByLastname(String lastname);

  User findByEmailAddress(String emailAddress);
}</programlisting>
          </example>

          <para>Declaring this method <classname>GenericJpaDao</classname>
          will try to resolve a call to this method to a named query starting
          with the simple name of the configured domain class followed by the
          method name separated by a dot. Note, that Hades distinguishes
          between query methods for a single object or lists of object. It
          will try to retrieve a single result if you provide a return value
          assignable from the configured domain class. Otherwise i will try to
          call a named query to return a list. Be sure your named query for a
          single instance truely returns only one instance.</para>
        </simplesect>
      </section>

      <section id="finder-methods.at-query">
        <title>Using @Query</title>

        <para>Using named queries to declare queries for entities is a valid
        approach and works fine for a small number amount of queries. As the
        queries themselves are tied to a Java method to execute them you
        actually can bind them to the query executing methods using Hades
        <code>@Query</code> annotation rather than annotating them to the
        domain class. This will free the domain class from persistence
        specific information and colocate the query to the DAO
        interface.</para>

        <para>Querys annotated to the query method will trump queries defined
        using <code>@NamedQuery</code> or named queries declared in in
        <filename>orm.xml</filename>.</para>

        <example>
          <title>Declare query at the query method using @Query</title>

          <programlisting language="java">public interface UserDao extends GenericDao&lt;User, Long&gt; {

  @Query("FROM User u WHERE u.emailAddress = ?1")
  User findByEmailAddress(String emailAddress);
}</programlisting>
        </example>
      </section>

      <section>
        <title>Using named parameters</title>

        <para>By default Hades will use position based parameter binding as
        described in all the samples above. This makes query methods a little
        error prone to refactorings regarding the parameter position. To solve
        this issue you can use <code>@Param</code> annotation to give a method
        parameter a cncrete name and bind the name in the query:</para>

        <example>
          <title>Using named parameters</title>

          <programlisting language="java">public interface UserDao extends GenericDao&lt;User, Long&gt; {

  @Query("FROM User u WHERE u.firstname = :firstname or u.lastname = :lastname")
  User findByLastnameOrFirstname(@Param("lastname") String lastname
                                 @Param("firstname") String firstname;
}</programlisting>

          <para>Note that the method parameters are switched according to the
          occurrence in the query defined.</para>
        </example>
      </section>

      <section>
        <title>Special parameter handling</title>

        <para>To hand parameters to your query you simply define method
        parameters as already seen in in examples above. Besides that Hades
        recognizes certain Hades specific types to apply pagination and
        sorting to your queries dynamically.</para>

        <example>
          <title>Using Pageable and Sort in query methods</title>

          <para><programlisting>Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);

List&lt;User&gt; findByLastname(String lastname, Sort sort);

List&lt;User&gt; findByLastname(String lastname, Pageable pageable);</programlisting>The
          first method allows you to pass a <code>Pageable</code> instance to
          the query method to dynamically add paging to your statically
          defined query. <code>Sorting</code> options are handed via the
          <interfacename>Pageable</interfacename> instance, too. If you only
          need sorting, simply add a <code>Sort</code> parameter to your
          method. As you also can see, simply returning a
          <interfacename>List</interfacename> is possible, too. Hades will
          then not retrieve the additional metadata required to build the
          actual <interfacename>Page</interfacename> instance but rather
          simply restrict the query to lookup only the given rante of
          entities.</para>
        </example>
      </section>

      <section>
        <title>Modifying queries</title>

        <para>All the sections before described how to declare queries to
        access a given entity or collection of entitites. Of course you can
        add custom modifying behaviour by using facilities described in <xref
        linkend="custom-implementations" />. As this approach is feasible for
        comprehensive custom functionality, you can achieve the execution of
        modifying queries that actually only need parameter binding by
        annotating the query method with <code>@Modifying</code>:</para>

        <example>
          <title>Declaring manipulating queries</title>

          <programlisting language="java">@Modifying
@Query("update User u set u.firstname = ?1 where u.lastname = ?2")
Long setFixedFirstnameFor(String firstname, String lastname);</programlisting>
        </example>

        <para>This will trigger the query annotated to the method as updating
        query instead of a selecting one.</para>
      </section>
    </section>

    <section>
      <title>Specifications</title>

      <para>JPA 2 introduces a criteria API that can be used to build queries
      programatically. Writing a criteria you actually define the where-clause
      of a query for a query of the handled domain class. Taking another step
      back these criterias can be regarded as predicate over the entity that
      is verbalized by the JPA criteria API constraints.</para>

      <para>Hades now takes the concept of a specification from Eric Evans'
      book Domain Driven Design, that carries the same semantics and provides
      an API to define such <interfacename>Specification</interfacename>s
      using the JPA criteria API. Thus you find methods like this in
      <interfacename>GenericDao</interfacename>:</para>

      <programlisting language="java">List&lt;T&gt; readAll(Specification&lt;T&gt; spec);</programlisting>

      <para>The <interfacename>Specification</interfacename> interface now
      looks as follows:</para>

      <programlisting language="java">public interface Specification&lt;T&gt; {
  Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;T&gt; query,
            CriteriaBuilder builder);
}</programlisting>

      <para>Okay, so what is the typical use case?
      <interfacename>Specification</interfacename>s can easily be used to
      build an extensible set of predicates on top of an entity that then can
      be combined and used with <interfacename>GenericDao</interfacename>
      without the need of declaring a query (method) for every needed
      combination of those. Here's an example:</para>

      <example>
        <title>Specifications for a Customer</title>

        <programlisting language="java">public class CustomerSpecs {

  public static Specification&lt;Customer&gt; isLongTermCustomer() {
    return new Specification&lt;Customer&gt;() {
      Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;T&gt; query,
            CriteriaBuilder builder) {

         LocalDate date = new LocalDate().minusYears(2);
         return builder.lessThan(root.get(Customer_.createdAt), date);
      }
    };
  }


  public static Specification&lt;Customer&gt; hasSalesOfMoreThan(MontaryAmount value) {
    return new Specification&lt;Customer&gt;() {
      Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;T&gt; query,
            CriteriaBuilder builder) {

         // build query here
      }
    };
  }
}</programlisting>
      </example>

      <para>Admittedly the amount of boilerplate leaves room for improvement
      (that will hopefully be reduced by Java 7 closures) but the client side
      becomes much nicer as you will see below. Besides that we have expressed
      some criteria on a business requirement abstraction level and created
      executable <interfacename>Specification</interfacename>s. So a client
      might use a <interfacename>Specification</interfacename> as
      follows:</para>

      <example>
        <title>Using a simple Specification</title>

        <programlisting language="java">List&lt;Customer&gt; customers = customerDao.readAll(isLongTermCustomer());</programlisting>
      </example>

      <para>Okay, why not simply creating a query for this kind of data
      access? You're right. Using a single
      <interfacename>Specification</interfacename> does not gain a lot of
      benefit over a plain query declaration. The power of
      <interfacename>Specification</interfacename>s really exposes when you
      combine them to create new <interfacename>Specification</interfacename>
      objects. You can achieve this through the
      <classname>Specifications</classname> helper class Hades provides to
      build expressions like this:</para>

      <example>
        <title>Combined Specifications</title>

        <para><programlisting language="java">MonetaryAmount amount = new MonetaryAmount(200.0, Currencies.DOLLAR);
List&lt;Customer&gt; customers = customerDao.readAll(
  where(isLongTermCustomer()).or(hasSalesOfMoreThan(amount)));</programlisting>As
        you can see, <classname>Specifications</classname> offers some
        gluecode methods to chain and combine
        <interfacename>Specification</interfacename>s. Thus extending your
        data access layer is just a matter of creating new
        <interfacename>Specification</interfacename> implementations and
        combining them with ones already existing.</para>
      </example>
    </section>

    <section>
      <title>Transactionality</title>

      <para>As of version 2.0 Hades CRUD methods on DAO instances are
      transactional by default. For reading operations the transaction
      configuration <code>readOnly</code> flag is set to true, all others are
      configured with a plain <classname>@Transactional</classname> so that
      default transaction configuration applies. For details see JavaDoc of
      <classname>GenericJpaDao</classname>. If you need to tweak transaction
      configuration for one of the methods declared in
      <interfacename>GenericDao</interfacename> simply redeclare the method in
      your DAO interface as follows:</para>

      <example>
        <title>Custom transaction configuration for CRUD</title>

        <programlisting language="java">public interface UserDao extends GenericDao&lt;User, Long&gt; {

  @Override
  @Transactional(timeout = 10)
  public List&lt;User&gt; readAll();

  // Further DAO method declarations
}</programlisting>

        <para>This will cause the <methodname>readAll()</methodname> method to
        be executed with a timeout of 10 seconds and without the
        <code>readOnly</code> flag.</para>
      </example>

      <para>Another possibility to alter transactional behaviour is by using a
      facade or service implementation that typically covers more than one DAO
      the. Its purpose is to define transactional boundaries for non-CRUD
      operations:</para>

      <example>
        <title>Using a facade to define transactions for multiple DAO
        calls</title>

        <programlisting language="java">@Service
class UserManagementImpl implements UserManagement {

  private final UserDao userDao;
  private final RoleDao roleDao;

  @Autowired
  public UserManagementImpl(UserDao userDao, RoleDao roleDao) {
    this.userDao = userDao;
    this.roleDao = roleDao;
  }

  @Transactional
  public void addRoleToAllUsers(String roleName) {

    Role role = roleDao.findByName(roleName);

    for (User user : userDao.readAll()) {
      user.addRole(role);
      userDao.save(user);
    }
}</programlisting>

        <para>This will cause call to
        <methodname>addRoleToAllUsers(…)</methodname> to run inside a
        transaction (participating in an existing one or create a new one if
        none already running). The transaction configuration at the DAOs will
        be neglected then as the outer transaction configuration determines
        the actual one used. Note that you will have to activate
        <code>&lt;tx:annotation-driven /&gt;</code> explicitly to get
        annotation based configuration at facades working. The example above
        assumes you're using component scanning.</para>
      </example>

      <section>
        <title>Transactional query methods</title>

        <para>To let your query methods be transactional simply use
        <interfacename>@Transactional</interfacename> at the DAO interface you
        define.</para>

        <example>
          <title>Using @Transactional at query methods</title>

          <programlisting language="java">@Transactional(readOnly = true)
public interface UserDao extends GenericDao&lt;User, Long&gt; {

  List&lt;User&gt; findByLastname(String lastname);

  @Modifying
  @Transactional
  @Query("delete from User u where u.active = false")
  void deleteInactiveUsers();
}</programlisting>

          <para>Typically you will use the <code>readOnly</code> flag set to
          true as most of the query methods will be reading ones. In contrast
          to that <methodname>deleteInactiveUsers()</methodname> makes use of
          the <interfacename>@Modifying</interfacename> annotation and
          overrides the transaction configuration. Thus the method will be
          executed with <code>readOnly</code> flag set to false.</para>
        </example>

        <note>
          <para>It's definately reasonable to use transactions for read only
          queries as we can mark them as such by setting the
          <code>readOnly</code> flag. This will not act as check that you do
          not trigger a manipulating query nevertheless (although some
          databases reject e.g. <literal>INSERT</literal> or
          <literal>UPDATE</literal> statements inside a transaction set to be
          read only) but gets propagated as hint to the underlying JDBC driver
          to do performance optimizations. Furthermore Spring will do some
          optimizations to the underlying JPA provider. E.g. when used with
          Hibernate the flush mode is set to <code>NEVER</code> when you
          configure a transaction as read only which causes Hibernate to skip
          dirty checks that gets quite noticeable on large object
          trees.</para>
        </note>
      </section>
    </section>

    <section>
      <title>Auditable entities</title>

      <para>Suppose you want to keep track of who created user entities and
      who changed them. All you need to do is implement
      <interfacename>Auditable</interfacename> interface</para>

      <example>
        <title>AuditableUser</title>

        <programlisting language="java">@Entity
public class AuditableUser implements Auditable&lt;User, Long&gt; {

  @Id
  @GeneratedValue(strategy = GenerationType.AUTO)
  private Long id;

  private User createdUser;
  private Date createdDate;
  private User modifiedUser;
  private Date modifiedDate;

  // Getters and setters according to Auditable and 
  // Persistable omitted
}</programlisting>
      </example>

      <para>Suppose you have the following three configuration files
      <filename>infrastructure.xml</filename> (for infrastructure setup),
      <filename>audition-context.xml</filename> (to setup the audition advice)
      and <filename>dao-context.xml</filename> (for the actual DAOs) the work
      of the <classname>AuditingAdvice</classname> can be demonstrated by the
      following testcase:</para>

      <example>
        <title>Testcase for <classname>AuditingAdvice</classname></title>

        <programlistingco>
          <areaspec>
            <area coords="1" id="auditing-advice-test.superclass" />

            <area coords="8" id="auditing-advice-test.reference-to-beans" />

            <area coords="13" id="auditing-advice-test.test-data" />

            <area coords="23" id="auditing-advice-test.setup" />

            <area coords="40" id="auditing-advice-test.test-method" />
          </areaspec>

          <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(location = { "infrastructure.xml", 
  "audition-context.xml", "dao-context.xml" })
@Transactional
public class AuditionAdviceTest extends AbstractJpaTests {

  @Autowired
  private UserDao userDao;

  @Autowired
  private AuditionAdvice advice;

  private AuditableUser user;
  
  @Before
  public void setUp() {

    user = new AuditableUser();
    user.setUsername("username");
    user.setPassword("password");
    user.setEmailAddress("foo@bar.com");

    AuditorAware auditorAware = Mockito.mock(
      AuditorAware.class);
    Mockito.when(auditorAware.getCurrentUser())
      .thenReturn(user);

    advice.setAuditorAware();
  }

  @Test
  public void testApplicationOfAuditionAdvice() {

    user = userDao.save(user);

    assertEquals(user, user.getCreatedBy());
    assertNotNull(user.getCreationDate());

    assertEquals(user, user.getLastModifiedBy());
    assertNotNull(user.getLastModifiedDate());
  }
}</programlisting>

          <calloutlist>
            <callout arearefs="auditing-advice-test.superclass">
              <para>Configure the test class to be dependency injected and
              transactional.</para>
            </callout>

            <callout arearefs="auditing-advice-test.reference-to-beans">
              <para>References to Spring beans.</para>
            </callout>

            <callout arearefs="auditing-advice-test.test-data">
              <para>Test user to be inserted into the database.</para>
            </callout>

            <callout arearefs="auditing-advice-test.setup">
              <para>Create a dummy <classname>User</classname> instance and a
              mock <interfacename>CurrentUserAware</interfacename>, that
              always returns the dummy user. Apply this mock to the
              advice.</para>
            </callout>

            <callout arearefs="auditing-advice-test.test-method">
              <para>The actual test simply saves the dummy
              <classname>User</classname> instance and verifys the advice got
              applied. Note that advice application is completely transparent
              to the client.</para>
            </callout>
          </calloutlist>
        </programlistingco>
      </example>
    </section>

    <section id="sample-app.base-classes">
      <title>Using abstract base classes</title>

      <para>Using Hades you can implement data acces for plain JPA entities as
      you like. So these entity classes usually share a common basic setup,
      e.g. an id property with an <code>@Id</code> annotation and an
      id-generation strategy applied. So Hades provides a simple base class
      you can inherit with your entities from and thus free it from the noise
      of these rather technical properties.</para>

      <para>Using <classname>AbstractPersistable</classname> would simplify
      User code like this</para>

      <example>
        <title>User based on
        <classname>AbstractPersistable</classname></title>

        <programlisting language="java">@Entity
public class User extends AbstractPersistable&lt;Long&gt; {

  public static final long = 123L;

  private String username;
  private String password;
  private String emailAddress;

  @ManyToMany
  private Set&lt;Role&gt; roles;

  // Further getters and setters omitted
}</programlisting>
      </example>

      <para>Note that almost technical artefacts are gone.</para>

      <para>If you are using auditable entities
      <classname>AbstractAuditable</classname> is your base class of choice.
      This will save you from writing getters and setters for 4 class
      members</para>

      <example>
        <title><classname>AuditableUser</classname> based on
        <classname>AbstractAuditable</classname></title>

        <programlisting language="java">@Entity
public class AuditableUser extends AbstractAuditable&lt;User, Long&gt; {

  public static final long = 123L;s

  private String username;
  private String password;
  private String emailAddress;

  @ManyToMany
  private Set&lt;Role&gt; roles;
}</programlisting>
      </example>
    </section>

    <section id="custom-implementations">
      <title>Custom implementations</title>

      <para>Often it is necessary to provide a custom implementation for a few
      DAO methods. Hades eases custom DAO functionality development a lot and
      allows easy integration with hades generic DAO and query method
      functionality. To enrich a generic DAO with custom functionality you
      have to define an interface and an implementation for that functionality
      first and let the DAO interface you provide by now extend that custom
      interface.</para>

      <example>
        <title>Interface for custom DAO functionality</title>

        <programlisting language="java">public interface UserDaoCustom {

  public void someCustomMethod(User user);
}</programlisting>
      </example>

      <example>
        <title>Implementation of custom DAO functionality</title>

        <para><programlisting language="java">public class UserDaoImpl implements UserDaoCustom {

  public void someCustomMethod(User user) {
    // Your custom implementation
  }
}</programlisting>Note that the implementation itself does not depend on Hades
        and can be a regular Spring bean. So you can either use standard
        dependency injection behaviour to inject references to other beans,
        take part in aspects and so on.</para>
      </example>

      <example>
        <title>Changes to the standard DAO interface</title>

        <para><programlisting language="java">public interface UserDao extends GenericDao&lt;User, Long&gt;, UserDaoCustom {

  // Declare query methods here
}</programlisting>Let your standard DAO interface extend the custom one. This
        makes generic DAO and custom functionality available to
        clients.</para>
      </example>

      <simplesect>
        <title>Configuration</title>

        <para>If you use namespace configuration Hades tries to autodetect
        custom implementations by looking up classes in the configured dao
        package using the naming conventions for the DAO interface but
        appending the property <code>dao-impl-postfix</code> to the classname.
        This prefix defaults to <code>DaoImpl</code>.</para>

        <example>
          <title>Configuration example</title>

          <para><programlisting language="xml">&lt;dao-config base-package="foo.bar.dao"&gt;
  &lt;dao id="userDao" /&gt;
&lt;/dao-config&gt;

&lt;dao-config base-package="foo.bar.dao" dao-impl-postfix="FooBar"&gt;
  &lt;dao id="userDao" /&gt;
&lt;/dao-config&gt;</programlisting></para>
        </example>

        <para>The first configuration example will try to lookup a class
        <classname>foo.bar.dao.UserDaoImpl</classname> to act as custom DAO
        implementation, where the second example will try to lookup
        <classname>foo.bar.dao.UserDaoFooBar</classname>.</para>
      </simplesect>

      <simplesect>
        <title>Manual wiring</title>

        <para>The approach above works perfectly well if your custom
        implementation uses annotation based configuration and autowring
        entirely as will be trated as any other Spring bean. If your customly
        implemented bean needs some special wiring you simply declare the bean
        and name it after the conventions just descibed. Hades will the pick
        up the custom bean by name rather than creating an own
        instance.</para>

        <example>
          <title>Manual wiring of custom implementations (I)</title>

          <programlisting language="xml">&lt;dao-config base-package="foo.bar.dao"&gt;
  &lt;dao id="userDao" /&gt;
&lt;/dao-config&gt;

&lt;bean id="userDaoImpl" class="..."&gt;
  &lt;!-- further configuration --&gt;
&lt;/bean&gt;</programlisting>

          <para>This also works if you use automatic DAO lookup without
          defining single <code>&lt;dao /&gt;</code> elements.</para>
        </example>

        <para>In case you are not in control of the implementation bean name
        (e.g. if you wrap a generic dao facade around an existing DAO
        implementation) you can explicitly tell the <code>&lt;dao /&gt;</code>
        element which bean to use as custom implementation by using the
        dao-impl-ref attribute.</para>

        <example>
          <title>Manual wiring of custom implementations (II)</title>

          <para><programlisting language="xml">&lt;dao-config base-package="foo.bar.dao"&gt;
  &lt;dao id="userDao" dao-impl-ref="customDaoImplementation" /&gt;
&lt;/dao-config&gt;

&lt;bean id="customDaoImplementation" class="..."&gt;
  &lt;!-- further configuration --&gt;
&lt;/bean&gt;</programlisting></para>
        </example>
      </simplesect>
    </section>

    <section>
      <title>Custom implementations</title>

      <section id="single-dao-behaviour">
        <title>Adding behaviour to single DAOs</title>

        <para>Often it is necessary to provide a custom implementation for a
        few DAO methods. Hades eases custom DAO functionality development a
        lot and allows easy integration with hades generic DAO and query
        method functionality. To enrich a generic DAO with custom
        functionality you have to define an interface and an implementation
        for that functionality first and let the DAO interface you provide by
        now extend that custom interface.</para>

        <example>
          <title>Interface for custom DAO functionality</title>

          <programlisting language="java">public interface UserDaoCustom {

  public void someCustomMethod(User user);
}</programlisting>
        </example>

        <example>
          <title>Implementation of custom DAO functionality</title>

          <para><programlisting language="java">public class UserDaoImpl implements UserDaoCustom {

  public void someCustomMethod(User user) {
    // Your custom implementation
  }
}</programlisting>Note that the implementation itself does not depend on Hades
          and can be a regular Spring bean. So you can either use standard
          dependency injection behaviour to inject references to other beans,
          take part in aspects and so on.</para>
        </example>

        <example>
          <title>Changes to the standard DAO interface</title>

          <para><programlisting language="java">public interface UserDao extends GenericDao&lt;User, Long&gt;, UserDaoCustom {

  // Declare query methods here
}</programlisting>Let your standard DAO interface extend the custom one. This
          makes generic DAO and custom functionality available to
          clients.</para>
        </example>

        <simplesect>
          <title>Configuration</title>

          <para>If you use namespace configuration Hades tries to autodetect
          custom implementations by looking up classes in the configured dao
          package using the naming conventions for the DAO interface but
          appending the property <code>dao-impl-postfix</code> to the
          classname. This prefix defaults to <code>DaoImpl</code>.</para>

          <example>
            <title>Configuration example</title>

            <para><programlisting language="xml">&lt;dao-config base-package="foo.bar.dao"&gt;
  &lt;dao id="userDao" /&gt;
&lt;/dao-config&gt;

&lt;dao-config base-package="foo.bar.dao" dao-impl-postfix="FooBar"&gt;
  &lt;dao id="userDao" /&gt;
&lt;/dao-config&gt;</programlisting></para>
          </example>

          <para>The first configuration example will try to lookup a class
          <classname>foo.bar.dao.UserDaoImpl</classname> to act as custom DAO
          implementation, where the second example will try to lookup
          <classname>foo.bar.dao.UserDaoFooBar</classname>.</para>
        </simplesect>

        <simplesect>
          <title>Manual wiring</title>

          <para>The approach above works perfectly well if your custom
          implementation uses annotation based configuration and autowring
          entirely as will be trated as any other Spring bean. If your
          customly implemented bean needs some special wiring you simply
          declare the bean and name it after the conventions just descibed.
          Hades will the pick up the custom bean by name rather than creating
          an own instance.</para>

          <example>
            <title>Manual wiring of custom implementations (I)</title>

            <programlisting language="xml">&lt;dao-config base-package="foo.bar.dao"&gt;
  &lt;dao id="userDao" /&gt;
&lt;/dao-config&gt;

&lt;bean id="userDaoImpl" class="…"&gt;
  &lt;!-- further configuration --&gt;
&lt;/bean&gt;</programlisting>

            <para>This also works if you use automatic DAO lookup without
            defining single <code>&lt;dao /&gt;</code> elements.</para>
          </example>

          <para>In case you are not in control of the implementation bean name
          (e.g. if you wrap a generic dao facade around an existing DAO
          implementation) you can explicitly tell the <code>&lt;dao
          /&gt;</code> element which bean to use as custom implementation by
          using the dao-impl-ref attribute.</para>

          <example>
            <title>Manual wiring of custom implementations (II)</title>

            <para><programlisting language="xml">&lt;dao-config base-package="foo.bar.dao"&gt;
  &lt;dao id="userDao" dao-impl-ref="customDaoImplementation" /&gt;
&lt;/dao-config&gt;

&lt;bean id="customDaoImplementation" class="…"&gt;
  &lt;!-- further configuration --&gt;
&lt;/bean&gt;</programlisting></para>
          </example>
        </simplesect>
      </section>

      <section>
        <title>Adding custom behaviour to all DAOs</title>

        <para>In other cases you might want to add a single method to all of
        your DAOs. So the approach just shown is not feasible. The first step
        to achieve this is adding and intermediate interface to declare the
        shared behaviour</para>

        <example>
          <title>An interface declaring custom shared behaviour</title>

          <para><programlisting language="java">public interface MyGenericDao&lt;T, PK extends Serializable&gt; 
  extends GenericDao&lt;T, PK&gt; {

  void sharedCustomMethod(PK id);
}</programlisting></para>
        </example>

        <para>Now your individual DAO interfaces will extend this intermediate
        interface to include the functionality declared. The second step is to
        create an implementation of this interface that extends
        <classname>GenericJpaDao</classname> and will act as custom base class
        for the DAO proxies then.</para>

        <note>
          <para>If you're using automatic DAO interface detection using the
          Spring namespace using the interface just as is will cause Spring
          trying to create an instance of
          <interfacename>MyGenericDao</interfacename>. This is of course not
          desired as it just acts as indermediate between
          <interfacename>GenericDao</interfacename> and the actual DAO
          interfaces you want to define for each entity. To exclude an
          interface extending <interfacename>GenericDao</interfacename> from
          being instantiated as DAO instance annotate it with
          <interfacename>@NoDaoBean</interfacename>.</para>
        </note>

        <example>
          <title>Custom DAO base class</title>

          <programlisting language="java">public class MyGenericDaoImpl&lt;T, PK extends Serializable&gt; 
  extends GenericJpaDao&lt;T, PK&gt; implements MyGenericDao&lt;T, PK&gt; {

  public void sharedCustomMethod(PK id) {
    // implementation goes here
  } 
}</programlisting>
        </example>

        <para>In the general case you will extend
        <classname>GenericJpaDao</classname>. In case you rely on behaviour
        provided by special JPA providers you might want to extend the
        appropriate base class (e.g.
        <classname>GenericHibernateJpaDao</classname>). So you can simply
        instantiate <classname>MyGenericDaoImpl</classname>. The last step to
        get this implementation used as base class for Hades DAOs is replacing
        the standard <classname>GenericDaoFactoryBean</classname> with a
        custom one overriding <methodname>getDaoClass()</methodname> returning
        your custom implementation.</para>

        <example>
          <title>Custom DAO factory bean</title>

          <programlisting language="java">public class MyGenericDaoFactory&lt;T extends GenericDao&lt;?, ?&gt; 
  extends GenericDaoFactoryBean&lt;T&gt; {

  protected Class&lt;? extends GenericJpaDao&gt; getDaoClass() {
    return MyGenericDaoImpl.class;
  }
}</programlisting>
        </example>

        <para>Finally you can either declare beans of the custom factory
        directly or use the <code>factory-class</code> attribute of the Spring
        namespace to tell Hades to use your custom factory
        implementation.</para>

        <example>
          <title>Using the custom factory with the namespace</title>

          <programlisting language="xml">&lt;dao-config base-package="foo.bar.dao" 
  factory-class="com.acme.MyGenericDaoFactory" /&gt;</programlisting>
        </example>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Eclipse plugin</title>

    <abstract>
      <para>To tightly integrate Hades into your application it is useful to
      leverage the features provided by Spring IDE. You can achieve this using
      the Hades Eclipse plugin. This chapter explains in detail how to install
      the plugin and what features you can expect by it.</para>
    </abstract>

    <section>
      <title>Installation</title>

      <para>You can install the plugin by simply pointing your Eclipse update
      manager to <ulink
      url="http://updatesite.synyx.org">http://updatesite.synyx.org</ulink>
      and choosing the Hades Namespace Integration.</para>
    </section>

    <section>
      <title>Features</title>

      <simplesect>
        <title>Code completion for XML elements attributes</title>

        <para>By handing over the Hades XSD you gain code completion for XML
        elements and especially attributes. This regards
        <code>base-package</code> in particular as well as the
        custom-element-ref attribute in the &lt;dao /&gt; element.</para>
      </simplesect>

      <simplesect>
        <title>Beans detection using automatic dao detection mode</title>

        <para>If you use the automatic DAO detection mode as shown in <xref
        linkend="hades-xml-editor" /> you will get all discovered DAO beans
        correctly listed in the Spring Elements section of your Project
        Explorer. The beans also lists property values like the query lookup
        strategy including implicit defaults.</para>
      </simplesect>

      <simplesect>
        <title>Marking the DAO interfaces to be Spring beans</title>

        <para>The DAO interfaces Hades creates beans for are marked with the
        usual Spring Bean S you are used to from other bean classes.</para>
      </simplesect>

      <simplesect>
        <title>Content assist for bean references is aware of Hades
        beans</title>

        <para>Trying to reference a DAO bean will now correctly show up the
        beans as suggestions during content assist.</para>

        <figure id="hades-xml-editor">
          <title>Hades integration into Spring IDE</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/hades-xml-editor.png" width="100%" />
            </imageobject>
          </mediaobject>
        </figure>
      </simplesect>
    </section>
  </chapter>

  <appendix>
    <title>Namespace reference</title>

    <section>
      <title>The <code>&lt;dao-config /&gt;</code> element</title>

      <para>The <code>&lt;dao-config /&gt;</code> element acts as container
      for <code>&lt;dao /&gt;</code> elements or can be left empty to trigger
      auto detection<footnote>
          <para>see <xref linkend="config.autoconfig" /></para>
        </footnote> of DAO instances. Attributes defined for
      <code>&lt;dao-config /&gt;</code> act are propagated to contained
      <code>&lt;dao /&gt;</code> elements but can be overridden of
      course.</para>

      <table>
        <title>Attributes</title>

        <tgroup cols="2">
          <colspec colwidth="1*" />

          <colspec colwidth="2*" />

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>base-package</code></entry>

              <entry>Defines the package to be used to construct DAO inteface
              names from or to be scanned for DAO interfaces extending
              <interfacename>GenericDao</interfacename> in auto detection
              mode. All packages below the configured package will be scanned,
              too. In auto configuration mode (no nested <code>&lt;dao
              /&gt;</code> elements) wildcards are also allowed.</entry>
            </row>

            <row>
              <entry><code>dao-impl-postfix</code></entry>

              <entry>Defines the postfix to autodetect custom DAO
              implementations. Classes whose names end with the configured
              postfix will be considered as candidates. Defaults to
              <code>Impl</code>.</entry>
            </row>

            <row>
              <entry><code>query-lookup-strategy</code></entry>

              <entry>Determines the strategy to be used to create finder
              queries. See <xref linkend="sample-app.finders.strategies" />
              for details. Defaults to
              <code>create-if-not-found</code>.</entry>
            </row>

            <row>
              <entry>entity-manager-factory-ref</entry>

              <entry>Possibility to wire an
              <interfacename>EntityManagerFactory</interfacename> explicitly
              in case multiple ones could be resolved.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>The <code>&lt;dao /&gt;</code> element</title>

      <para>The <code>&lt;dao /&gt;</code> element can contain all attributes
      of <code>&lt;dao-config /&gt;</code> except <code>base-package</code>.
      This will result in overriding the values configured in the surrounding
      <code>&lt;dao-config /&gt;</code> block. Thus here we will only document
      extended attributes.</para>

      <table>
        <title>Attributes</title>

        <tgroup cols="2">
          <colspec colwidth="1*" />

          <colspec colwidth="2*" />

          <tbody>
            <row>
              <entry><code>id</code></entry>

              <entry>Defines the id of the bean the DAO instance will be
              registered under as well as the DAO interface name.</entry>
            </row>

            <row>
              <entry><code>custom-impl-ref</code></entry>

              <entry>Defines a reference to a custom DAO implementation
              bean.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </appendix>

  <appendix>
    <title>Frequently asked questions</title>

    <qandaset>
      <qandadiv>
        <title>Common</title>

        <qandaentry>
          <question>
            <para>I'd like to get more detailled logging information on what
            methods are called inside
            <interfacename>GenericDao</interfacename>, e.g. How can I gain
            them?</para>
          </question>

          <answer>
            <para>You can make use of
            <classname>CustomizableTraceInterceptor</classname> provided by
            Spring:</para>

            <programlisting language="xml">&lt;bean id="customizableTraceInterceptor" class="
  org.springframework.aop.interceptor.CustomizableTraceInterceptor"&gt;
  &lt;property name="enterMessage" value="Entering $[methodName]($[arguments])"/&gt;
  &lt;property name="exitMessage" value="Leaving $[methodName](): $[returnValue]"/&gt;
&lt;/bean&gt;

&lt;aop:config&gt;
  &lt;aop:advisor advice-ref="customizableTraceInterceptor" 
    pointcut="execution(public * org.synyx.hades.dao.GenericDao+.*(..))"/&gt;
&lt;/aop:config&gt;</programlisting>
          </answer>
        </qandaentry>
      </qandadiv>

      <qandadiv>
        <title>Infrastructure</title>

        <qandaentry>
          <question>
            <para>Currently I have implemented a DAO layer based on
            <classname>HibernateDaoSupport</classname>. I create a
            <classname>SessionFactory</classname> by using Springs
            <classname>AnnotationSessionFactoryBean</classname>. How do I get
            Hades DAOs working in this environment.</para>
          </question>

          <answer>
            <para>You have to replace
            <classname>AnnotationSessionFactoryBean</classname> with the
            <classname>LocalContainerEntityManagerFactoryBean</classname> as
            described in <xref
            linkend="infrastructure.entity-manager-factory" />. Supposed you
            have registered it under <code>entityManagerFactory</code> you can
            reference it in you DAOs based on
            <classname>HibernateDaoSupport</classname> as follows:</para>

            <example>
              <title>Looking up a SessionFactory from an
              HibernateEntityManagerFactory</title>

              <programlisting language="xml">&lt;bean class="com.acme.YourDaoBasedOnHibernateDaoSupport"&gt;
  &lt;property name="sessionFactory"&gt;
    &lt;bean factory-bean="entityManagerFactory" 
      factory-method="getSessionFactory" /&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>
            </example>
          </answer>
        </qandaentry>
      </qandadiv>

      <qandadiv>
        <title>Auditing</title>

        <qandaentry>
          <question>
            <para>I want to use Hades auditing capabilities but have my
            database already set up to set modification and creation date on
            entities. How to prevent Hades to set the date
            programmatically.</para>
          </question>

          <answer>
            <para>Just configure <classname>AuditingAdvice</classname>
            accordingly. The property you might want to look for is
            <code>dateTimeForNow</code>.</para>
          </answer>
        </qandaentry>
      </qandadiv>
    </qandaset>
  </appendix>

  <glossary>
    <glossdiv>
      <title>A</title>

      <glossentry>
        <glossterm>AOP</glossterm>

        <glossdef>
          <para>Aspect oriented programming</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>C</title>

      <glossentry>
        <glossterm>Commons DBCP</glossterm>

        <glossdef>
          <para>Commons DataBase Connection Pools - Library of the Apache
          foundation offering pooling implementations of the
          <interfacename>DataSource</interfacename> interface.</para>
        </glossdef>
      </glossentry>

      <glossentry>
        <glossterm>CRUD</glossterm>

        <glossdef>
          <para>Create, Read, Update, Delete - Basic persistence
          operations</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>D</title>

      <glossentry>
        <glossterm>DAO</glossterm>

        <glossdef>
          <para>Data Access Object - Pattern to separate persisting logic from
          the object to be persisted</para>
        </glossdef>
      </glossentry>

      <glossentry>
        <glossterm>Dependency Injection</glossterm>

        <glossdef>
          <para>Pattern to hand a component's dependency to the component from
          outside, freeing the component to lookup the dependant itself. For
          more information see <ulink
          url="http://en.wikipedia.org/wiki/Dependency_Injection">http://en.wikipedia.org/wiki/Dependency_Injection</ulink>.</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>E</title>

      <glossentry>
        <glossterm>EclipseLink</glossterm>

        <glossdef>
          <para>Object relational mapper implementing JPA - <ulink
          url="http://www.eclipselink.org">http://www.eclipselink.org</ulink></para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>H</title>

      <glossentry>
        <glossterm>Hibernate</glossterm>

        <glossdef>
          <para>Object relational mapper implementing JPA - <ulink
          url="http://www.hibernate.org">http://www.hibernate.org</ulink></para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>J</title>

      <glossentry>
        <glossterm>JPA</glossterm>

        <glossdef>
          <para>Java Persistence Api</para>
        </glossdef>
      </glossentry>
    </glossdiv>

    <glossdiv>
      <title>S</title>

      <glossentry>
        <glossterm>Spring</glossterm>

        <glossdef>
          <para>Java application framework - <ulink
          url="http://www.springframework.org">http://www.springframework.org</ulink></para>
        </glossdef>
      </glossentry>
    </glossdiv>
  </glossary>
</book>